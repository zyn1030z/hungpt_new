[{"content":"Trong bài viết lần này, mình sẽ hướng dẫn các bạn tạo ra 1 widget để hỗ trợ chúng ta vẽ dashboard\n1.Thư viện Chart Odoo Đầu tiên chúng ta sẽ tìm hiểu về thư viện Chart của Odoo, bạn có thể tìm thấy nó theo đường dẫn \u0026lsquo;/web/static/lib/Chart/Chart.js\u0026rsquo;\nCác biểu đồ được sử dụng phổ biến trong Chart.js bao gồm:\n Scatter Plot Chart Line Chart Bar Chart Pie Chart Doughnut Chart  Để có thể sử dụng biểu đồ Chart trong Odoo chúng ta có thể thêm vào file xml, sau đó thêm vào file manifest như sau:\nTiếp theo chúng ta cần thêm đoạn code sau vào nơi mà chúng ta muốn hiển thị biểu đồ trong file xml như sau:\n\u0026lt;canvas id=\u0026quot;chart_example\u0026quot; height=\u0026quot;400px\u0026quot; width=\u0026quot;400px\u0026quot;/\u0026gt; Về cơ bản thì cú pháp để truyền tham số vào Chart sẽ như sau:\nnew Chart(“id of canvas”, { type = “type of graph”, data = { “data of the graph” }, options = {“options of the graph” } }); type, data, options sẽ phụ thuôc vào loại biểu đồ mà chúng ta muốn hiển thị, mình sẽ đưa ra một số loại biểu đồ cũng như cách sử dụng của chúng dưới đây\nScatter Plot Chart Dưới đây là đoạn code ví dụ cho biểu đồ này:\nvar chart = new Chart(\u0026quot;chart_example\u0026quot;, { type: \u0026quot;scatter\u0026quot;, data: { datasets: [{ data: [{ x: 10, y: 10 }, { x: 20, y: 20 }, { x: 30, y: 30 }, { x: 40, y: 40 }, { x: 50, y: 50 }], pointBackgroundColor: \u0026quot;black\u0026quot;, }] }, options: {} }); Để có thể hiển thị lên giao diện Chart trong odoo, có rất nhiều cách khác nhau, tuy nhiên ở bài viết lần này mình sẽ tạo 1 widget cho từng biểu đồ cũng như thêm trực tiếp dữ liệu tạo vào trong file js, thực tế các dữ liệu mà chúng ta truyền vào như, chiều rộng, kích thước các cột, số liệu ra sao chúng ta phải xử lý bên python, có thể viết field đó là compute hoặc gọi rpc\nCode js widget như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  odoo.define(\u0026#39;chart_dashboard.chart_dashboard_scatter\u0026#39;, function (require) { \u0026#34;use strict\u0026#34;; var fieldRegistry = require(\u0026#39;web.field_registry\u0026#39;); var AbstractField = require(\u0026#39;web.AbstractField\u0026#39;); var core = require(\u0026#39;web.core\u0026#39;); var _t = core._t; var FieldChartWidget = AbstractField.extend({ supportedFieldTypes: [\u0026#39;char\u0026#39;, \u0026#39;text\u0026#39;], jsLibs: [ \u0026#39;/web/static/lib/Chart/Chart.js\u0026#39;, ], _render: function () { var self = this; var $canvas = $(\u0026#39;\u0026lt;canvas/\u0026gt;\u0026#39;); if (this.chart) { this.chart.destroy(); } this.$el.empty(); this.$el.append($canvas); this.chart = new Chart($canvas, { type: \u0026#34;scatter\u0026#34;, data: { datasets: [{ data: [{ x: 10, y: 10 }, { x: 20, y: 20 }, { x: 30, y: 30 }, { x: 40, y: 40 }, { x: 50, y: 50 }], pointBackgroundColor: \u0026#34;black\u0026#34;, }] }, options: {} }); return this._super.apply(this, arguments); }, }); fieldRegistry.add(\u0026#39;chart_scatter\u0026#39;, FieldChartWidget); return { FieldChartWidget: FieldChartWidget }; });   Code file xml mình để như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;record model=\u0026#34;ir.ui.view\u0026#34; id=\u0026#34;chart_dashboard\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;chart_dasboard\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;chart.dashboard\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;form checkDirty=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-6\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;text-uppercase default-color\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;em class=\u0026#34;fa fa-list-ol\u0026#34; /\u0026gt; Dashboard Scatter \u0026lt;/div\u0026gt;\u0026lt;hr/\u0026gt; \u0026lt;field name=\u0026#34;value1\u0026#34; widget=\u0026#34;chart_scatter\u0026#34; class=\u0026#34;dashboard_ren_chart\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;   Mình có thêm 1 file css\n1 2 3  .dashboard_ren_chart { width: 50%; }   Và đây là kết quả:\nLine Chart Đoạn code chúng ta truyền vào đối với biểu đồ này như sau:\n1 2 3 4 5 6 7 8 9 10 11  var chart = new Chart(\u0026#34;chart_example\u0026#34;, { type: \u0026#34;line\u0026#34;, data: { labels: [10, 20, 30, 40, 50], datasets: [{ data: [10, 20, 30, 40, 50], pointBackgroundColor: \u0026#34;black\u0026#34;, }] }, option: {} });   Mình cũng sẽ tạo 1 widget như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  odoo.define(\u0026#39;chart_dashboard.chart_dashboard_line\u0026#39;, function (require) { \u0026#34;use strict\u0026#34;; var fieldRegistry = require(\u0026#39;web.field_registry\u0026#39;); var AbstractField = require(\u0026#39;web.AbstractField\u0026#39;); var core = require(\u0026#39;web.core\u0026#39;); var _t = core._t; var FieldChartWidget = AbstractField.extend({ supportedFieldTypes: [\u0026#39;char\u0026#39;, \u0026#39;text\u0026#39;], jsLibs: [ \u0026#39;/web/static/lib/Chart/Chart.js\u0026#39;, ], _render: function () { var self = this; var $canvas = $(\u0026#39;\u0026lt;canvas/\u0026gt;\u0026#39;); if (this.chart) { this.chart.destroy(); } this.$el.empty(); this.$el.append($canvas); this.chart = new Chart($canvas, { type: \u0026#34;line\u0026#34;, data: { labels: [10, 20, 30, 40, 50], datasets: [{ data: [10, 20, 30, 40, 50], pointBackgroundColor: \u0026#34;black\u0026#34;, }] }, option: {} }); return this._super.apply(this, arguments); }, }); fieldRegistry.add(\u0026#39;chart_line\u0026#39;, FieldChartWidget); return { FieldChartWidget: FieldChartWidget }; });   Và đây là kết quả\nBar Chart Biểu đồ dạng thanh được sử dụng nhiều nhất trong odoo, chúng ta cũng có thể tùy chỉnh màu sắc, chiều rộng chiều cao…\nDưới đây là đoạn code ví dụ:\n1 2 3 4 5 6 7 8 9 10 11  var chart = new Chart(\u0026#34;chart_example\u0026#34;, { type: \u0026#34;bar\u0026#34;, data: { labels: [\u0026#34;bar1\u0026#34;, \u0026#34;bar2\u0026#34;, \u0026#34;bar3\u0026#34;, \u0026#34;bar4\u0026#34;], datasets: [{ backgroundColor: \u0026#34;black\u0026#34;, data: [0, 10, 20, 30] }] }, options: {} });   Chúng ta sẽ viết 1 widget như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  odoo.define(\u0026#39;chart_dashboard.chart_dashboard_bar\u0026#39;, function (require) { \u0026#34;use strict\u0026#34;; var fieldRegistry = require(\u0026#39;web.field_registry\u0026#39;); var AbstractField = require(\u0026#39;web.AbstractField\u0026#39;); var core = require(\u0026#39;web.core\u0026#39;); var _t = core._t; var FieldChartWidget = AbstractField.extend({ supportedFieldTypes: [\u0026#39;char\u0026#39;, \u0026#39;text\u0026#39;], jsLibs: [ \u0026#39;/web/static/lib/Chart/Chart.js\u0026#39;, ], _render: function () { var self = this; var $canvas = $(\u0026#39;\u0026lt;canvas/\u0026gt;\u0026#39;); if (this.chart) { this.chart.destroy(); } this.$el.empty(); this.$el.append($canvas); this.chart = new Chart($canvas, { type: \u0026#34;bar\u0026#34;, data: { labels: [\u0026#34;bar1\u0026#34;, \u0026#34;bar2\u0026#34;, \u0026#34;bar3\u0026#34;, \u0026#34;bar4\u0026#34;], datasets: [{ backgroundColor: \u0026#34;black\u0026#34;, data: [0, 10, 20, 30] }] }, options: {} }); return this._super.apply(this, arguments); }, }); fieldRegistry.add(\u0026#39;chart_bar\u0026#39;, FieldChartWidget); return { FieldChartWidget: FieldChartWidget }; });   Và đây là kết quả\nPie Chart Tiếp theo chúng ta đến với biểu đồ tròn, dưới đây là đoạn code ví dụ:\n1 2 3 4 5 6 7 8 9 10  var chart = new Chart(\u0026#34;chart_example\u0026#34;, { type: \u0026#34;pie\u0026#34;, data: { datasets: [{ backgroundColor: \u0026#34;black\u0026#34;, data: [0, 10, 20, 30, 40] }] }, options: {} });   Chúng ta sẽ tạo 1 widget như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  odoo.define(\u0026#39;chart_dashboard.chart_dashboard_bar\u0026#39;, function (require) { \u0026#34;use strict\u0026#34;; var fieldRegistry = require(\u0026#39;web.field_registry\u0026#39;); var AbstractField = require(\u0026#39;web.AbstractField\u0026#39;); var core = require(\u0026#39;web.core\u0026#39;); var _t = core._t; var FieldChartWidget = AbstractField.extend({ supportedFieldTypes: [\u0026#39;char\u0026#39;, \u0026#39;text\u0026#39;], jsLibs: [ \u0026#39;/web/static/lib/Chart/Chart.js\u0026#39;, ], _render: function () { var self = this; var $canvas = $(\u0026#39;\u0026lt;canvas/\u0026gt;\u0026#39;); if (this.chart) { this.chart.destroy(); } this.$el.empty(); this.$el.append($canvas); this.chart = new Chart($canvas, { type: \u0026#34;bar\u0026#34;, data: { labels: [\u0026#34;bar1\u0026#34;, \u0026#34;bar2\u0026#34;, \u0026#34;bar3\u0026#34;, \u0026#34;bar4\u0026#34;], datasets: [{ backgroundColor: \u0026#34;black\u0026#34;, data: [0, 10, 20, 30] }] }, options: {} }); return this._super.apply(this, arguments); }, }); fieldRegistry.add(\u0026#39;chart_bar\u0026#39;, FieldChartWidget); return { FieldChartWidget: FieldChartWidget }; });   Và đây là kết quả\nDoughnut chart Biểu đồ này cũng tương tự như biểu đồ tròn, dưới đây là đoạn code mẫu\n1 2 3 4 5 6 7 8 9 10 11  var chart = new Chart(\u0026#34;chart_example\u0026#34;, { type: \u0026#34;doughnut\u0026#34;, data: { datasets: [{ backgroundColor: \u0026#34;black\u0026#34;, data: [0, 10, 20, 30, 40] }] }, options: { } });   Chúng ta sẽ viết 1 widget như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  odoo.define(\u0026#39;chart_dashboard.chart_dashboard_doughnut\u0026#39;, function (require) { \u0026#34;use strict\u0026#34;; var fieldRegistry = require(\u0026#39;web.field_registry\u0026#39;); var AbstractField = require(\u0026#39;web.AbstractField\u0026#39;); var core = require(\u0026#39;web.core\u0026#39;); var _t = core._t; var FieldChartWidget = AbstractField.extend({ supportedFieldTypes: [\u0026#39;char\u0026#39;, \u0026#39;text\u0026#39;], jsLibs: [ \u0026#39;/web/static/lib/Chart/Chart.js\u0026#39;, ], _render: function () { var self = this; var $canvas = $(\u0026#39;\u0026lt;canvas/\u0026gt;\u0026#39;); if (this.chart) { this.chart.destroy(); } this.$el.empty(); this.$el.append($canvas); this.chart = new Chart($canvas, { type: \u0026#34;doughnut\u0026#34;, data: { datasets: [{ backgroundColor: \u0026#34;black\u0026#34;, data: [0, 10, 20, 30, 40] }] }, options: {} }); return this._super.apply(this, arguments); }, }); fieldRegistry.add(\u0026#39;chart_doughnut\u0026#39;, FieldChartWidget); return { FieldChartWidget: FieldChartWidget }; });   dưới đây là kết quả:\n2. Truyền dữ liệu từ field vào widget dashboard Bước đầu tiên chúng ta sẽ tạo ra 1 ir.actions.server mục đích để khi chúng ta bấm vào chart_dashboard, chúng ta sẽ truyền giá trị tương ứng vào view thông qua hàm python viết trong ir.actions.server\nĐây là đoạn code view cơ bản mình đã viết trong đó record có id là chart_dashboard sẽ là dashboard mà chúng ta cần xử lý trong bài viết lần này\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  \u0026lt;odoo\u0026gt; \u0026lt;data\u0026gt; \u0026lt;record model=\u0026#34;ir.ui.view\u0026#34; id=\u0026#34;chart_dashboard\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;chart_dasboard\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;chart.dashboard\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;form checkDirty=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;record model=\u0026#34;ir.actions.server\u0026#34; id=\u0026#34;chart_dashboard_server_action\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Dashboard\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model_id\u0026#34; ref=\u0026#34;chart_dashboard.model_chart_dashboard\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;state\u0026#34;\u0026gt;code\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;code\u0026#34;\u0026gt; action=model.show_dashboard() \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;record model=\u0026#34;ir.actions.act_window\u0026#34; id=\u0026#34;chart_dashboard_action_window\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;chart_dashboard window\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;res_model\u0026#34;\u0026gt;chart.dashboard\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;view_mode\u0026#34;\u0026gt;form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;view_id\u0026#34; ref=\u0026#34;chart_dashboard\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;target\u0026#34;\u0026gt;inline\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;!-- Top menu item --\u0026gt; \u0026lt;menuitem name=\u0026#34;chart_dashboard\u0026#34; id=\u0026#34;chart_dashboard_menu_root\u0026#34; web_icon=\u0026#34;chart_dashboard,static/description/img.png\u0026#34;/\u0026gt; \u0026lt;menuitem id=\u0026#34;chart_dashboard_menu\u0026#34; action=\u0026#34;chart_dashboard_server_action\u0026#34; parent=\u0026#34;chart_dashboard_menu_root\u0026#34; name=\u0026#34;Chart Dashboard\u0026#34; sequence=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/odoo\u0026gt;   ở phần 1, dữ liệu mình truyền vào widget là trong file js, tuy nhiên thực tế, chúng ta sẽ truyền từ python qua. Cụ thể mình sẽ viết 1 field compute, trả về giá trị như mình truyền vào file js bên trên như sau:\n1 2 3 4 5 6 7 8 9 10 11  { type: \u0026#34;doughnut\u0026#34;, data: { datasets: [{ backgroundColor: \u0026#34;black\u0026#34;, data: [0, 10, 20, 30, 40] }] }, options: { } }   Chúng ta có thể lấy được giá trị của field từ hàm _render thông qua biến this.value, khi lấy được giá trị field rồi, chúng ta sẽ chỉnh sửa để cho vào js trong widget\nChúng ta sẽ tạo 1 field và viết hàm compute cho nó như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13  value6 = fields.Text(compute=\u0026#34;_compute_value_6\u0026#34;) def _compute_value_6(self): for rc in self: rc.value6 = json.dumps({ \u0026#39;type\u0026#39;: \u0026#34;doughnut\u0026#34;, \u0026#39;data\u0026#39;: { \u0026#39;datasets\u0026#39;: [{ \u0026#39;backgroundColor\u0026#39;: \u0026#34;black\u0026#34;, \u0026#39;data\u0026#39;: [0, 10, 20, 30, 40] }] }, \u0026#39;options\u0026#39;: {} })   Trong hàm _render, chúng ta thử log gía trị this.value xem nó trả ra gì nhé!\nChúng ta chỉ cần sửa hàm _render như sau, chúng ta sẽ có kết quả hiển thị biểu đồ tương tự:\n1 2 3 4 5 6 7 8 9 10 11 12  _render: function () { var self = this; var $canvas = $(\u0026#39;\u0026lt;canvas/\u0026gt;\u0026#39;); if (this.chart) { this.chart.destroy(); } this.$el.empty(); this.$el.append($canvas); var config = JSON.parse(this.value); this.chart = new Chart($canvas,config) return this._super.apply(this, arguments); },   Bài viết về dashboard trong Odoo của mình cũng dừng lại ở đây, hẹn mọi người vào những bài viết tiếp theo nhé!😀\n","description":"","id":2,"section":"posts","tags":["Odoo","OWL"],"title":"Tạo widget dashboard với thư viện Chart trong Odoo","uri":"https://hungpt.info/en/posts/how_to_use_widget_chart_in_odoo13/"},{"content":"Trong những năm gần đây các library/framework JavaScript cả front-end lẫn back-end đều lũ lượt ra đời và phát triển mạnh mẽ như Reactjs, VueJS\u0026hellip; Odoo cũng vậy từ bản Odoo 14 cũng đã có framework mới là OWL.\nCòn tiếp\u0026hellip;..\n","description":"","id":3,"section":"posts","tags":["OWL","Odoo"],"title":"OWL là gì? Những điều cần biết khi mới tìm hiểu về OWL?","uri":"https://hungpt.info/en/posts/owl-tutorial-part1/"},{"content":"Kubernetes là công cụ điều phối phổ biến nhất để triển khai và nhân rộng các hệ thống được đóng gói(docker\u0026hellip;). Bạn có thể sử dụng Kubernetes để xây dựng và phân phối các ứng dụng của mình trên cloud một cách đáng tin cậy.\nTrong bài hướng dẫn dành cho người mới bắt đầu này, bạn sẽ tìm hiểu những gì Kubernetes có thể làm và cách bắt đầu sử dụng K8S qua một số ví dụ cụ thể.\n1. Kubernetes là gì? Kubernetes, hoặc k8s là một nền tảng mã nguồn mở tự động hoá việc quản lý, scaling và triển khai ứng dụng dưới dạng container hay còn gọi là Container orchestration engine. Nó loại bỏ rất nhiều các quy trình thủ công liên quan đến việc triển khai và mở rộng các containerized applications.\nGần đây, nhiều ứng dụng đã thực hiện container hoá bằng cách sử dụng docker và sử dụng nó như là môi trường production ngày càng tăng. Trên môi trường production, việc cấu trúc hệ thống chạy bằng container chỉ sử dụng docker là rất khó khăn. Cho nên việc sử dụng một nền tảng Container orchestration engine như là k8s thì khá phổ biến hiện nay.\nCác ứng dụng production thực tế mở rộng nhiều containers. Các containers đó phải được triển khai trên nhiều server hosts. Kubernetes cung cấp khả năng phối hợp và quản lý cần thiết để triển khai các containers theo quy mô cho các workloads đó.\n2. Tính năng Bằng việc sử dụng docker, trên 1 host bạn có thể tạo ra nhiều container. Tuy nhiên nếu bạn có ý định sử dụng trên môi trường production thì phải bắt buộc phải nghĩ đến những vấn đề dưới đây:\n Việc quản lý hàng loạt docker host Container Scheduling Rolling update Scaling/Auto Scaling Monitor vòng đời và tình trạng sống chết của container. Self-hearing trong trường hợp có lỗi xãy ra. (Có khả năng phát hiện và tự correct lỗi) Service discovery Load balancing Quản lý data, work node, log Infrastructure as Code Sự liên kết và mở rộng với các hệ thống khác  3. Kubernetes hoạt động như thế nào? Container thiết lập ứng dụng dưới hình thức di động và kiến trúc K8s được sử dụng để chạy các ứng dụng đó. Một cụm K8s bao gồm một Control Plan và một nút thực thi. Trong đó, Control Plan có nhiệm vụ hiển thị API K8s và quản lý các nút.\nĐơn vị thực thi nhỏ nhất cho một ứng dụng đang chạy trong Kubernetes là Kubernetes Pod, bao gồm một hoặc nhiều container. Kubernetes Pods chạy trên các nút thực thi.\nCác chức năng của K8s cũng là thành phần của Control Plan và thực thi trên các nút K8s.\nControl Plan có bốn thành phần chính  Kube-apiserver giúp hiển thị API Kubernetes. etcd. là kho lưu trữ khóa-giá trị nơi lưu trữ tất cả dữ liệu liên quan đến cụm Kubernetes. Kube-scheduler giúp theo dõi các Kubernetes Pods linh hoạt không cần nút. Kube-controller-manager được sử dụng để quản lý và điều khiển các chức năng.  Nút K8s có ba thành phần chính  Kubelet đảm bảo các container cần thiết cho Kubernetes Pod. Kube-proxy giúp duy trì các quy tắc mạng và cho phép giao tiếp. Container runtime là các phần mềm chạy container tuân thủ Kubernetes CRI.  Một số điều khoản bổ sung cần lưu ý  Kubernetes service sử dụng một chức năng để thực hiện các nhiệm vụ được yêu cầu. Controller đảm bảo trạng thái hiện tại của Kubernetes đáp ứng với mong muốn sử dụng. Operator có khả năng tự động hoá các tác vụ độc quyền giúp triển khai và quản lý ứng dụng trên K8s dễ dàng hơn.  4. Thuật ngữ và khái niệm cơ bản Master node Là server điều khiển các máy Worker chạy ứng dụng. Master node bao gồm 4 thành phần chính:\n Kubernetes API Server: là thành phần giúp các thành phần khác liên lạc nói chuyện với nhau. Lập trình viên khi triển khai ứng dụng sẽ gọi API Kubernetes API Server này. Scheduler: Thành phần này lập lịch triển khai cho các ứng dụng, ưng dụng được đặt vào Worker nào để chạy Controler Manager: Thành phần đảm nhiệm phần quản lý các Worker, kiểm tra các Worker sống hay chết, đảm nhận việc nhân bản ứng dụng… Etcd: Đây là cơ sở dữ liệu của Kubernetes, tất cả các thông tin của Kubernetes được lưu trữ cố định vào đây.  Worker node Là server chạy ứng dụng trên đó. Bao gồm 3 thành phần chính:\n Container runtime: Là thành phần giúp chạy các ứng dụng dưới dạng Container. Thông thường người ta sử dụng Docker. Kubelet: đây là thành phần giao tiếp với Kubernetes API Server, và cũng quản lý các container Kubernetes Service Proxy: Thành phần này đảm nhận việc phân tải giữa các ứng dụng  kubectl Tool quản trị Kubernetes, được cài đặt trên các máy trạm, cho phép các lập trình viên đẩy các ứng dụng mô tả triển khai vào cụm Kubernetes, cũng như là cho phép các quản trị viên có thể quản trị được cụm Kubernetes.\nPod Pod là khái niệm cơ bản và quan trọng nhất trên Kubernetes. Bản thân Pod có thể chứa 1 hoặc nhiều hơn 1 container. Pod chính là nơi ứng dụng được chạy trong đó. Pod là các tiến trình nằm trên các Worker Node. Bản thân Pod có tài nguyên riêng về file system, cpu, ram, volumes, địa chỉ network…\nImage Là phần mềm chạy ứng dụng đã được gói lại thành một chương trình để có thể chạy dưới dạng container. Các Pod sẽ sử dụng các Image để chạy.\nCác Image này thông thường quản lý ở một nơi lưu trữ tập trung, ví dụ chúng ta có Docker Hub là nơi chứa Images của nhiều ứng dụng phổ biến như nginx, mysql, wordpress…\nDeployment Là cách thức để giúp triển khai, cập nhật, quản trị Pod.\nReplicas Controller Là thành phần quản trị bản sao của Pod, giúp nhân bản hoặc giảm số lượng Pod.\nService Là phần mạng (network) của Kubernetes giúp cho các Pod gọi nhau ổn định hơn, hoặc để Load Balancing giữa nhiều bản sao của Pod, và có thể dùng để dẫn traffic từ người dùng vào ứng dụng (Pod), giúp người dùng có thể sử dụng được ứng dụng.\nLabel Label ra đời để phân loại và quản lý Pod,. Ví dụ chúng ta có thể đánh nhãn các Pod chạy ở theo chức năng frontend, backend, chạy ở môi trường dev, qc, uat, production…\n5. Sử dụng Kubectl để tương tác với Kubernetes Còn tiếp\u0026hellip;\n","description":"Kubernetes là công cụ điều phối phổ biến nhất để triển khai và nhân rộng các hệ thống được đóng gói(docker...). Bạn có thể sử dụng Kubernetes để xây dựng và phân phối các ứng dụng của mình trên cloud một cách đáng tin cậy.","id":4,"section":"posts","tags":["K8s","Devops","AWS"],"title":"Hướng dẫn Kubernetes cho người mới bắt đầu – Các khái niệm \u0026 ví dụ cơ bản","uri":"https://hungpt.info/en/posts/kubernetes-tutorial/"},{"content":"Trong bài lab lần này, chúng ta sẽ tìm hiểu về docker. Vậy docker là gì?\nDocker là nền tảng phần mềm cho phép bạn dựng, kiểm thử và triển khai ứng dụng một cách nhanh chóng.\nDocker đóng gói phần mềm vào các đơn vị tiêu chuẩn hóa được gọi là container có mọi thứ mà phần mềm cần để chạy, trong đó có thư viện, công cụ hệ thống, mã và thời gian chạy. Bằng cách sử dụng Docker, bạn có thể nhanh chóng triển khai và thay đổi quy mô ứng dụng vào bất kỳ môi trường nào và biết chắc rằng mã của bạn sẽ chạy được.\nNhưng để dễ tiếp cận nhất, cứ coi docker là máy ảo với các thành phần như:\n Docker hub: Là cloud lưu trữ các Docker image (Giống như AMI của AWS) Docker Container : Là các Instance (Giống như EC2 trong AWS) Docker Network: Có các tính năng tương tự như network của VMware/Virtualbox Docker volume: Có thể mount các thư mục trên máy host(máy thật) vào Container, hoặc có thể sử dụng ổ mạng nếy để Container instance có bị reset, tạo lại Container cũng không bị mất dữ liệu Docker Container sẽ stopped/Exited ngay lập tức nếy trong Container không có chương trình nào đang chạy. Nên có thể gọi container với /bin/bash nếu không có gì chạy trong Instance Container\nTrên docker hub có sẵn gần như các loại image cho mọi như cầu phổ biến. Tuy nhiên, nếu muốn, có thể tạo Clean Image ban đầu từ bộ hệ điều hành có sẵn.\nVí dụ: tạo image CleanUbuntu trên máy ảo EC2 từ bộ cài Ubuntu 20.04(tên mã là focal):  Bước 1: Chuẩn bị máy ảo EC2 chạy Ubuntu. Cài đặt công cụ tạo bộ cài Ubuntu với lệnh sau: sudo apt-get update sudo apt install debootstrap Bước 2: Cài đặt docker Chạy lệnh tạo file system cài ubuntu 20.04(focal) vào thư mục con focal trong thư mục này với lệnh sau:\nsudo debootstrap focal focal ls focal Cài đặt phần mềm docker lên EC2:\nsudo apt install docker.io -y Bước 3: Tạo docker image pwd sudo tar -C focal -c. | sudo docker import - focal Chạy thêm 1 container khác:\nsudo docker run -it focal /bin/bash Xem các container trên máy:\nsudo docker container ls -a Nếu muốn chạy docker không cần quyền sudo thì add USER vào group docker:\nsudo usermod -aG docker $USER newgrp docker //để việc thay đổi có hiệu lực hoặc exec su -l $USER Kiểm tra log của container với lệnh sau:\nsudo ls /var/lib/docker/containers/ -la Giới hạn kích thước file log bằng cách cấu hình file : /etc/docker/daemon.json\nsudo nano /etc/docker/daemon.json Sửa nội dung file sau:\n{ \u0026quot;log-driver\u0026quot;:\u0026quot;json-file\u0026quot;, \u0026quot;log-opts\u0026quot;:{ \u0026quot;max-size\u0026quot;:\u0026quot;50m\u0026quot;, \u0026quot;max-file\u0026quot;:\u0026quot;7\u0026quot; } } Sau đó lưu lại và khởi động lại docker\nsudo systemctl restart docker Các container mới sẽ chịu cấu hình mặc định này\nExport và import image trong Docker Docker lưu repository chứa các image và các layer, container ở đường dẫn: /var/lib/docker\nNếu muốn export một image từ responsitory trở lại file tar để copy và import vào máy khác thì dùng lệnh:\ndocker save --output name.tar name_docker_image Sau khi copy xong, import sang máy khác chúng ta dùng lệnh:\ndocker load -i file.tar ","description":"Trong bài lab lần này, chúng ta sẽ tìm hiểu về docker. Vậy docker là gì? Docker là nền tảng phần mềm cho phép bạn dựng, kiểm thử và triển khai ứng dụng một cách nhanh chóng.","id":5,"section":"posts","tags":["docker","devops","aws"],"title":"Docker là gì? Kiến thức cơ bản về Docker","uri":"https://hungpt.info/en/posts/docker_part1/"},{"content":"Ở 3 phần trước chúng ta đã cùng tìm hiểu từng thành phần trong mô hình MVC của Javascript Odoo. Ở phần này, mình sẽ tạo ra 1 view OWL\nVậy bài viết này chúng ta sẽ xây dựng ra cái gì? Mình sẽ tạo 1 kiểu xem mới(ở odoo có các kiểu xem nhưu tree,kanban,chart), kiểu xem này hiển thị theo mô hình cha con phân cấp.\nRegistering 1 view type mới trong ir.ui.view model from odoo import fields, models class View(models.Model): _inherit = \u0026quot;ir.ui.view\u0026quot; type = fields.Selection(selection_add=[(\u0026quot;owl_tree\u0026quot;, \u0026quot;OWL Tree Vizualisation\u0026quot;)]) Thêm javascript trong Odoo \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;template id=\u0026quot;assets_backend\u0026quot; name=\u0026quot;assets_backend\u0026quot; inherit_id=\u0026quot;web.assets_backend\u0026quot;\u0026gt; \u0026lt;xpath expr=\u0026quot;.\u0026quot; position=\u0026quot;inside\u0026quot;\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/owl_tutorial_views/static/src/components/tree_item/TreeItem.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/owl_tutorial_views/static/src/owl_tree_view/owl_tree_view.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/owl_tutorial_views/static/src/owl_tree_view/owl_tree_model.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/owl_tutorial_views/static/src/owl_tree_view/owl_tree_controller.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/owl_tutorial_views/static/src/owl_tree_view/owl_tree_renderer.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/xpath\u0026gt; \u0026lt;xpath expr=\u0026quot;link[last()]\u0026quot; position=\u0026quot;after\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; type=\u0026quot;text/scss\u0026quot; href=\u0026quot;/owl_tutorial_views/static/src/components/tree_item/tree_item.scss\u0026quot;/\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; type=\u0026quot;text/scss\u0026quot; href=\u0026quot;/owl_tutorial_views/static/src/owl_tree_view/owl_tree_view.scss\u0026quot;/\u0026gt; \u0026lt;/xpath\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/odoo\u0026gt; Hiển thị view mới trong danh mục nhóm SP \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;record id=\u0026quot;product_category_view_owl_tree_view\u0026quot; model=\u0026quot;ir.ui.view\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;Product Categories\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;product.category\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;owl_tree\u0026gt;\u0026lt;/owl_tree\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;record id='product.product_category_action_form' model='ir.actions.act_window'\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;Product Categories\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;res_model\u0026quot;\u0026gt;product.category\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;view_mode\u0026quot;\u0026gt;tree,owl_tree,form\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt; Creating the View, Model, Controller and, Renderer. ├── owl_tree_view │ ├── owl_tree_controller.js │ ├── owl_tree_model.js │ ├── owl_tree_renderer.js │ ├── owl_tree_view.js │ └── owl_tree_view.scss └── xml └── owl_tree_view.xml Controller Bên trong tệp owl_tree_controller.js, chúng ta sẽ tạo OWLTreeController để mở rộng AbastractController:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  odoo.define(\u0026#34;owl_tutorial_views.OWLTreeController\u0026#34;, function (require) { \u0026#34;use strict\u0026#34;; var AbstractController = require(\u0026#34;web.AbstractController\u0026#34;); var OWLTreeController = AbstractController.extend({ custom_events: _.extend({}, AbstractController.prototype.custom_events, {}), /** * @override * @param parent * @param model * @param renderer * @param {Object} params */ init: function (parent, model, renderer, params) { this._super.apply(this, arguments); } }); return OWLTreeController; });   Hiện tại, Controller này chưa làm gì cả, init chỉ gọi hàm cha và không có custom_events nào được tạo ngay bây giờ, nhưng chúng ta sẽ tìm hiểu nó sau.\nModel Bên trong file owl_tree_model.js, mình sẽ tạo OWLTreeModel, model này sẽ thực hiện lấy dữ liệu đến server.\nỞ đây chúng ta sẽ overide lại 1 số hàm như:\n __load : chỉ được gọi lần đầu tiên để lấy dữ liệu từ server __reload: hàm này được gọi bởi controller khi có bất kỳ sự thay đổi nào phía UI, hàm này cũng lấy dữ liệu từ phía server __get: hàm này sẽ chuyển dữ liệu về Controller sau đó sẽ chuyển tới Render để hiển thị dữ liệu ra giao diện  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  odoo.define(\u0026#34;owl_tutorial_views.OWLTreeModel\u0026#34;, function (require) { \u0026#34;use strict\u0026#34;; var AbstractModel = require(\u0026#34;web.AbstractModel\u0026#34;); const OWLTreeModel = AbstractModel.extend({ __get: function () { return this.data; }, __load: function (params) { this.modelName = params.modelName; this.domain = [[\u0026#34;parent_id\u0026#34;, \u0026#34;=\u0026#34;, false]]; // this.domain = params.domain;  // It is the better to get domains from params  // but we will evolve our module later.  this.data = {}; return this._fetchData(); }, __reload: function (handle, params) { if (\u0026#34;domain\u0026#34; in params) { this.domain = params.domain; } return this._fetchData(); }, _fetchData: function () { var self = this; return this._rpc({ model: this.modelName, method: \u0026#34;search_read\u0026#34;, kwargs: { domain: this.domain, }, }).then(function (result) { self.data.items = result; }); }, }); return OWLTreeModel; });   Ở đây mình tạo ra 1 hàm _fetchData, hàm này có nhiệm vụ call RPC và có thể sử dụng ở nhiều chỗ khác nhau trong code của chúng ta.\nTrong hàm _load và hàm _reload có chứa tham số params trong đó có biến ‘domain , vì ứng dụng của chúng ta là hiển thị danh mục gốc sau đó đến danh mục con nên ở hàm _load chỉ chạy ở lần đầu tiên, chúng ta có thể đặt domain là [[“parent_id”, “=”, false]]\nKết quả mình lấy từ server sẽ lưu lại ở data.items. Điều này rất quan trọng bởi sau này bạn sẽ thấy OWL Render truy cập vào nhiều dữ liệu thông quan props để tạo thành 1 JS Object\nOWL Renderer Trong file owl_tree_renderer.js chúng ta sẽ kế thừa AbstractRendererOwl mà không kế thừa Component thông thường\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  odoo.define(\u0026#34;owl_tutorial_views.OWLTreeRenderer\u0026#34;, function (require) { \u0026#34;use strict\u0026#34;; const AbstractRendererOwl = require(\u0026#34;web.AbstractRendererOwl\u0026#34;); const patchMixin = require(\u0026#34;web.patchMixin\u0026#34;); const QWeb = require(\u0026#34;web.QWeb\u0026#34;); const session = require(\u0026#34;web.session\u0026#34;); const { useState } = owl.hooks; class OWLTreeRenderer extends AbstractRendererOwl { constructor(parent, props) { super(...arguments); this.qweb = new QWeb(this.env.isDebug(), { _s: session.origin }); this.state = useState({ localItems: props.items || [], }); } willUpdateProps(nextProps) { Object.assign(this.state, { localItems: nextProps.items, }); } } const components = { TreeItem: require(\u0026#34;owl_tutorial_views/static/src/components/tree_item/TreeItem.js\u0026#34;), }; Object.assign(OWLTreeRenderer, { components, defaultProps: { items: [], }, props: { arch: { type: Object, optional: true, }, items: { type: Array, }, isEmbedded: { type: Boolean, optional: true, }, noContentHelp: { type: String, optional: true, }, }, template: \u0026#34;owl_tutorial_views.OWLTreeRenderer\u0026#34;, }); return patchMixin(OWLTreeRenderer); });   Render sẽ được khởi tạo với các props, cái mà chúng ta sẽ lấy dữ liệu từ server từ Model.\nQWeb Template Ở file owl_tree_view.xml chúng ta viết như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;templates xml:space=\u0026#34;preserve\u0026#34;\u0026gt; \u0026lt;div t-name=\u0026#34;owl_tutorial_views.OWLTreeRenderer\u0026#34; class=\u0026#34;o_owl_tree_view\u0026#34; owl=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;d-flex p-2 flex-row owl-tree-root\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;list-group\u0026#34;\u0026gt; \u0026lt;t t-foreach=\u0026#34;props.items\u0026#34; t-as=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;TreeItem item=\u0026#34;item\u0026#34;/\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/templates\u0026gt;   View Cuối cùng chúng ta sẽ tạo 1 class View mở rộng từ AbtractView. Nó sẽ chịu trách nhiệm khởi tạo, kết nối tới Model, Controller và Render\nTrong file owl_tree_view.js chúng ta sẽ viết như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  odoo.define(\u0026#34;owl_tutorial_views.OWLTreeView\u0026#34;, function (require) { \u0026#34;use strict\u0026#34;; // Pulling the MVC parts  const OWLTreeController = require(\u0026#34;owl_tutorial_views.OWLTreeController\u0026#34;); const OWLTreeModel = require(\u0026#34;owl_tutorial_views.OWLTreeModel\u0026#34;); const OWLTreeRenderer = require(\u0026#34;owl_tutorial_views.OWLTreeRenderer\u0026#34;); const AbstractView = require(\u0026#34;web.AbstractView\u0026#34;); const core = require(\u0026#34;web.core\u0026#34;); // Our Renderer is an OWL Component so this is needed  const RendererWrapper = require(\u0026#34;web.RendererWrapper\u0026#34;); const view_registry = require(\u0026#34;web.view_registry\u0026#34;); const _lt = core._lt; const OWLTreeView = AbstractView.extend({ accesskey: \u0026#34;m\u0026#34;, display_name: _lt(\u0026#34;OWLTreeView\u0026#34;), icon: \u0026#34;fa-indent\u0026#34;, config: _.extend({}, AbstractView.prototype.config, { Controller: OWLTreeController, Model: OWLTreeModel, Renderer: OWLTreeRenderer, }), viewType: \u0026#34;owl_tree\u0026#34;, searchMenuTypes: [\u0026#34;filter\u0026#34;, \u0026#34;favorite\u0026#34;], /** * @override */ init: function () { this._super.apply(this, arguments); }, getRenderer(parent, state) { state = Object.assign(state || {}, this.rendererParams); return new RendererWrapper(parent, this.config.Renderer, state); }, }); // Make the view of type \u0026#34;owl_tree\u0026#34; actually available and valid  // if seen in an XML or an action.  view_registry.add(\u0026#34;owl_tree\u0026#34;, OWLTreeView); return OWLTreeView; });   Thêm CSS 1 2 3 4  .owl-tree-root { width: 1200px; height: 1200px; }   TreeItem OWL Component Chúng ta sẽ thêm component là TreeItem sẽ đại diện cho 1 button, mỗi TreeView sẽ có 1 trường child_id đại diện\nỞ đây mình sẽ tạo 1 folder components với các file như sau:\n. ├── components │ └── tree_item │ ├── TreeItem.js │ ├── TreeItem.xml │ └── tree_item.sc Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;templates xml:space=\u0026#34;preserve\u0026#34;\u0026gt; \u0026lt;t t-name=\u0026#34;owl_tutorial_views.TreeItem\u0026#34; owl=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;tree-item-wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;list-group-item list-group-item-action d-flex justify-content-between align-items-center owl-tree-item\u0026#34;\u0026gt; \u0026lt;span t-esc=\u0026#34;props.item.display_name\u0026#34;/\u0026gt; \u0026lt;span class=\u0026#34;badge badge-primary badge-pill\u0026#34; t-esc=\u0026#34;props.item.product_count\u0026#34;\u0026gt;4\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;t t-if=\u0026#34;props.item.child_id.length \u0026gt; 0\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;d-flex pl-4 py-1 flex-row treeview\u0026#34; t-if=\u0026#34;props.item.children and props.item.children.length \u0026gt; 0\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;list-group\u0026#34;\u0026gt; \u0026lt;t t-foreach=\u0026#34;props.item.children\u0026#34; t-as=\u0026#34;child_item\u0026#34;\u0026gt; \u0026lt;TreeItem item=\u0026#34;child_item\u0026#34;/\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/templates\u0026gt;   TreeItem.js Component 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  odoo.define( \u0026#34;owl_tutorial_views/static/src/components/tree_item/TreeItem.js\u0026#34;, function (require) { \u0026#34;use strict\u0026#34;; const { Component } = owl; const patchMixin = require(\u0026#34;web.patchMixin\u0026#34;); const { useState } = owl.hooks; class TreeItem extends Component { /** * @override */ constructor(...args) { super(...args); this.state = useState({}); } } Object.assign(TreeItem, { components: { TreeItem }, props: { item: {}, }, template: \u0026#34;owl_tutorial_views.TreeItem\u0026#34;, }); return patchMixin(TreeItem); } );   Vậy dòng Object.assign mục đích để làm gì?\nNếu bạn coi OWL là 1 thư viện javascript độc lập như ReactJS hay VueJS thì OWL sẽ khác 1 chút khi nó không định nghĩa các thuộc tính static trong 1 component.Để giải quyết vấn đề này, chúng ta sẽ sử dụng Object,asign\nVậy Object.assign là gì? Thì object.assign() là một method nhưng (multiple jobs) nó có nhiều nhiệm vụ trong đó bao gồm những nhiệm vụ copy an object, clone từ một object khác, và nối hai hay nhiều object lại với nhau.\nSCSS Styles 1 2 3  .tree-item-wrapper { min-width: 50em; }   ","description":"","id":6,"section":"posts","tags":["Odoo","OWL","Javascript"],"title":"Odoo JavaScript - Phần 4: Tạo OWL view","uri":"https://hungpt.info/en/posts/odoo-javascript-classes-and-mvc-architecture_part4/"},{"content":"MVC ở đây chúng ta có thể hiểu WebClient của odoo chính là view là Python chính là M và C.\nNhưng chúng ta nên nghĩ về WebClient như một application riêng biệt cũng cần có kiến trúc MVC riêng của nó.\nCác class base trong MVC Mình bắt đầu phân tích Kiến trúc MVC trong Odoo WebClient bằng cách đi vào mã nguồn bên trong /odoo/addons/web/static/src/core/mvc.js.\nNhìn hình bên trên chúng ta có thể thấy, file js này định nghĩa 4 thành phần chính tạo nên MVC đó là Model, Render, Controller và Factory.\n Model kiểm soát trạng thái, nó sẽ gọi máy chủ thông qua RPC để tìm nạp dữ liệu, cập nhật và tạo nó. Model không extend Widget bởi model chỉ chịu trách nhiệm cập nhật, thể hện trạng thái của dữ liệu(😁không biết mình nói vậy có đúng không nữa) Renderer được extend từ Widget có nhiệm vụ hiển thị dữ liệu cho end user thông qua việc thêm mọi thứ vào DOM. Class này k có quyền truy cập trực tiếp đến Model mà phải thông qua Controller và khi có sự kiện như click chuột,… thì Render sẽ dispath chúng đến Controller Controller có thể coi là một người điều phối giữ Model và Controller Factory hay còn gọi là View, nhiệm vụ chính là từ route URL nhận được, sẽ khởi tạo Model, Controller. Sau khi Controller hoạt động thì Factory sẽ không còn hoạt động nữa\nTừ 4 ý chính trên, bạn có thể vào code đọc từng phần để hiểu thêm nhé!  Các lớp trừu tượng của Kiến trúc MVC Như trong file mvc.js thì trong addons/web/static/src/js/views cũng được chia thành 4 lớp trừu tượng tương ứng với 4 file js\n AbstractModel (abstractmodel.js) AbstractRenderer (abstractrenderer.js) AbstractController (abstractcontroller.js) AbstractView (abstractview.js)\nVề bản chất 4 lớp trừu tượng này cũng là extend từ các class trong file mvc.js mà mình đã nói ở trên😁. Bây giờ cùng tìm hiểu từng AbtractClass xem chúng được viết thêm những gì nhé!\nNhìn có vẻ phức tạp nhỉ, ok chúng ta sẽ đi tới từng lớp trừu tượng một nhé!  Model Cũng giống như Model trong mvc.js, ở đây nó cũng có nhiệm vụ là nạp dữ liệu thông qua rpc và xử lý kết quả nhận được\nVí dụ với BasicModel (được sử dụng trong Form/List Views) BasicModel mở rộng AbstractModel và là một triển khai thực sự của lớp trừu tượng, để làm cho những gì chúng ta đã nói trước đó rõ ràng hơn một chút, chúng ta sẽ xem xét ví dụ sau\nBạn có thể theo đường dẫn addons/web/static/src/js/views/basic/basic_model.js, bạn sẽ thấy class BasicModel được extend từ AbstractModel\nở đây chúng ta có thể thấy hàm _load:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  _load: function (dataPoint, options) { if (options \u0026amp;\u0026amp; options.onlyGroups \u0026amp;\u0026amp; !(dataPoint.type === \u0026#39;list\u0026#39; \u0026amp;\u0026amp; dataPoint.groupedBy.length)) { return Promise.resolve(dataPoint); } if (dataPoint.type === \u0026#39;record\u0026#39;) { return this._fetchRecord(dataPoint, options); } if (dataPoint.type === \u0026#39;list\u0026#39; \u0026amp;\u0026amp; dataPoint.groupedBy.length) { return this._readGroup(dataPoint, options); } if (dataPoint.type === \u0026#39;list\u0026#39; \u0026amp;\u0026amp; !dataPoint.groupedBy.length) { return this._fetchUngroupedList(dataPoint, options); } },   Tương ứng với hàm _fetchRecord thực hiện gọi RPC và update dữ liệu hiển thị ra màn hình\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  _fetchRecord: function (record, options) { var self = this; options = options || {}; var fieldNames = options.fieldNames || record.getFieldNames(options); fieldNames = _.uniq(fieldNames.concat([\u0026#39;display_name\u0026#39;])); return this._rpc({ model: record.model, method: \u0026#39;read\u0026#39;, args: [[record.res_id], fieldNames], context: _.extend({bin_size: true}, record.getContext()), }) .then(function (result) { if (result.length === 0) { return Promise.reject(); } result = result[0]; record.data = _.extend({}, record.data, result); }) .then(function () { self._parseServerData(fieldNames, record, record.data); }) .then(function () { return Promise.all([ self._fetchX2Manys(record, options), self._fetchReferences(record, options) ]).then(function () { return self._postprocess(record, options); }); }); },   Từ 2 hàm trên chúng ta có thể thấy lớp trừu tượng model hoạt động như thế nào rồi phải không nhỉ?\nRenderer Như đã nói ở trên, Render nhằm mục đích hiển thị giao diện cho người dùng, cũng như tương tác với các sự kiện trên UI để chuyển về cho Controller\nTrong odoo 14, có 2 cách để bạn có thể tạo ra Render là extends AbstractRender hoặc tạo OWL Render, chúng tnhéa cùng đi nhanh qua 2 cách này\n Legacy AbstractRenderer\nChúng ta sẽ có 1 main function đó là _render mà cụ thể hơn nó gọi là _renderView bên dưới chứa logic của việc tạo giao diện người dùng.\nNhư đây là đoạn code của BasicRender:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  _render: function () { var oldAllFieldWidgets = this.allFieldWidgets; this.allFieldWidgets = {}; // TODO maybe merging allFieldWidgets and allModifiersData into \u0026#34;nodesData\u0026#34; in some way could be great  this.allModifiersData = []; var oldWidgets = this.widgets; this.widgets = []; return this._renderView().then(function () { _.each(oldAllFieldWidgets, function (recordWidgets) { _.each(recordWidgets, function (widget) { widget.destroy(); }); }); _.invoke(oldWidgets, \u0026#39;destroy\u0026#39;); }); },   Khi Controller muốn update, Render sẽ thiết lập và trả lại trạng thái của mình với getLocalState và setLocalState, trước khi được gỡ khỏi DOM, Rendercũng phải reset state với hàm resetLocalState\n OWL Renderer\nOwlRendererWrapper như một người đứng giữa Render và Controller  1 2 3 4 5 6  class RendererWrapper extends ComponentWrapper { getLocalState() { } setLocalState() { } giveFocus() { } resetLocalState() { } }   Theo như mình biết thì các hàm ở đây không làm gì cả, nếu bạn muốn chúng hoạt động được thì phải override lại nó\nVí dụ như class PivotRenderer override lại resetLocalState để đặt lại trạng thái OWL component. Bạn có thể vào code của core Odoo từ 14 trở lên tìm class PivotRenderer các bạn sẽ thấy như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  _resetState() { // This check is used to avoid the destruction of the dropdown.  // The click on the header bubbles to window in order to hide  // all the other dropdowns (in this component or other components).  // So we need isHeaderClicked to cancel this behaviour.  if (this.isHeaderClicked) { this.isHeaderClicked = false; return; } this.state.activeNodeHeader = { groupId: false, isXAxis: false, click: false }; }   Controller Controller thường quản lý giao tiếp giữa Render và Model. Nhưng nó cũng chịu trách nhiệm trả lời các sự kiện từ ControlPanel hoặc SearchPanel.\n1 2 3 4 5 6  _startRenderer: function () { if (this.renderer instanceof owl.Component) { return this.renderer.mount(this.$(\u0026#39;.o_content\u0026#39;)[0]); } return this.renderer.appendTo(this.$(\u0026#39;.o_content\u0026#39;)); },   Khi phương thức được start, Render sẽ được thêm vào DOM thông qua $el\nBây giờ chúng ta sẽ điểm qua 2 chức năng chính của Controller:\n Là cầu nối trung gian để giao tiếp giữa Render và Model\nThực tế Render sẽ kích hoạt một số sự kiện tới Controller và để đáp lại,Render sẽ thực hiện một số hành động\nVới sự trợ giúp của ActionsMixin, Controller có thể đăng ký một số custom-event mà Controller đang lắng nghe và xử lý  1 2 3 4 5  custom_events: _.extend({}, ActionMixin.custom_events, { navigation_move: \u0026#39;_onNavigationMove\u0026#39;, open_record: \u0026#39;_onOpenRecord\u0026#39;, switch_view: \u0026#39;_onSwitchView\u0026#39;, }),   Controller cũng xử lý một số sự kiện khi chúng ta click vào các nút trên giao diện có sẵn của Odoo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /** * This is the main entry point for the controller. Changes from the search * view arrive in this method, and internal changes can sometimes also call * this method. It is basically the way everything notifies the controller * that something has changed. * * The update method is responsible for fetching necessary data, then * updating the renderer and wait for the rendering to complete. * * @param {Object} params will be given to the model and to the renderer * @param {Object} [options={}] * @param {boolean} [options.reload=true] if true, the model will reload data * @returns {Promise} */ async update(params, options = {}) { const shouldReload = \u0026#39;reload\u0026#39; in options ? options.reload : true; if (shouldReload) { this.handle = await this.dp.add(this.model.reload(this.handle, params)); } const localState = this.renderer.getLocalState(); const state = this.model.get(this.handle, { withSampleData: true }); const promises = [ this._updateRendererState(state, params).then(() =\u0026gt; { this.renderer.setLocalState(localState); }), this._update(this.model.get(this.handle), params) ]; await this.dp.add(Promise.all(promises)); this.updateButtons(); this.el.classList.toggle(\u0026#39;o_view_sample_data\u0026#39;, this.model.isInSampleMode()); },    Truy cập vào Control Panel và Search Panel  1 2 3 4 5 6 7 8 9 10 11 12  if (this.withControlPanel) { this._updateControlPanelProps(this.initialState); this._controlPanelWrapper = new ComponentWrapper(this, this.ControlPanel, this.controlPanelProps); this._controlPanelWrapper.env.bus.on(\u0026#39;focus-view\u0026#39;, this, () =\u0026gt; this._giveFocus()); promises.push(this._controlPanelWrapper.mount(this.el, { position: \u0026#39;first-child\u0026#39; })); } if (this.withSearchPanel) { this._searchPanelWrapper = new ComponentWrapper(this, this.SearchPanel, this.searchPanelProps); const content = this.el.querySelector(\u0026#39;:scope .o_content\u0026#39;); content.classList.add(\u0026#39;o_controller_with_searchpanel\u0026#39;); promises.push(this._searchPanelWrapper.mount(content, { position: \u0026#39;first-child\u0026#39; })); }   View Khởi tạo 1 view thường có 2 tham số:\n1 2 3  init: function (viewInfo, params) { //... }   Mục tiêu chính của quá trình khởi tạo là điền các đối tượng cấu hình sẽ được chuyển đến các sub_component để tạo chúng:\n1 2 3 4  this.rendererParams = {}; this.controllerParams = {}; this.modelParams = {}; this.loadParams = {};   3 dòng đầu thể hiện rõ ứng với 3 phần là : Renderer, Controller và Model, còn ***this.loadParams = {};***LoadParams sẽ được sử dụng để tải dữ liệu ban đầu với _loadData và nó sẽ chứa thông tin nếu view đang được “mở” với group-bey, context, domain, limit\nMục tiêu đối với mình là hiểu cách thức JS View thực hiện khi chúng ta tạo ra và bắt đầu từ XML mà chúng ta thường code hằng ngày như thế nào?\n","description":"","id":7,"section":"posts","tags":["Odoo","OWL","Javascript"],"title":"Odoo JavaScript - Phần 3: Tổng quan về kiến trúc MVC trong Odoo","uri":"https://hungpt.info/en/posts/odoo-javascript-classes-and-mvc-architecture_part3/"},{"content":"Bài viết lần này, chúng ta cùng đi tìm hiểu sâu hơn về web.Widget class nhé!\nBên cạnh việc extend từ những mixin khác như ở phần 1 mình có nói thì mục đích chính của web.Widget đó chính là render Qweb, thực hiện quản lý life cycle và thêm vào DOM.\nWeb.Widget có các thuộc tính lấy cảm hứng từ BackboneJS hiển thị trong lớp như tagName,id, className, attributes, events, template\nxmlDependencies, cssLibs, jsLibs và assetLibs là những thức sẽ được tìm và load trước khi Widget được render.\nCần chú ý, ***web.Widget có 2 thuộc tính ẩn rất quan trọng như sau:\n el: là 1 DOM element được set giá trị khi chúng ta gọi hàm setElement $el : là biến Jquery đại diện cho el\nChú ý: Nếu bạn muốn truy cập đến this.el hoặc this.$el ở sai thời điểm của life cycle thì có thể trả về là undifine, 2 thuộc tính này chỉ có giá trị khi chúng ta hàm renderElement hoặc hàm attach to được gọi.  Render template Qweb 1 2 3 4 5 6 7 8 9 10 11 12 13 14  /** * Renders the element. The default implementation renders the widget using * QWeb, `this.template` must be defined. The context given to QWeb contains * the \u0026#34;widget\u0026#34; key that references `this`. */ renderElement: function () { var $el; if (this.template) { $el = $(core.qweb.render(this.template, {widget: this}).trim()); } else { $el = this._makeDescriptive(); } this._replaceElement($el); },   Lifecycle Vòng đời của 1 widget bao gồm init -\u0026gt; willStart -\u0026gt;[rendering]-\u0026gt; start -\u0026gt; destroy, tương ứng với các hàm có trong Widget.\n Hàm init  1 2 3 4 5 6 7 8 9 10 11 12 13  init: function (parent) { mixins.PropertiesMixin.init.call(this); this.setParent(parent); // Bind on_/do_* methods to this  // We might remove this automatic binding in the future  for (var name in this) { if(typeof(this[name]) === \u0026#34;function\u0026#34;) { if((/^on_|^do_/).test(name)) { this[name] = this[name].bind(this); } } } },    Hàm willStart sẽ thực hiện bất đồng bộ việc tải thư viện liên quan, file xml  1 2 3 4 5 6 7 8 9 10 11 12 13 14  * @returns {Promise} */ willStart: function () { var proms = []; if (this.xmlDependencies) { proms.push.apply(proms, _.map(this.xmlDependencies, function (xmlPath) { return ajax.loadXML(xmlPath, core.qweb); })); } if (this.jsLibs || this.cssLibs || this.assetLibs) { proms.push(this._loadLibs(this)); } return Promise.all(proms); },    Hàm start  1 2 3 4 5  * @returns {Promise} */ start: function () { return Promise.resolve(); },    Hàm destroy sẽ loại bỏ $ el khỏi DOM và xóa các phần tử con.  1 2 3 4 5 6  destroy: function () { mixins.PropertiesMixin.destroy.call(this); if (this.$el) { this.$el.remove(); } },   Insert DOM web.Widget có các hàm appendTo, insertAfter, attachTo, prependTo đều nhận đối số là 1 jquery element, bạn có thể tìm hiểu thêm trong code core của Odoo.\nTổng kết Widget là 1 trong những thành phần quan trọng nhất của Framework, mình khuyên bạn nên dành thời gian đi sâu vào mã nguồn, đọc lại phần giải thích của mình và xem qua tài liệu này\n","description":"","id":8,"section":"posts","tags":["Odoo","OWL","Javascript"],"title":"Odoo JavaScript - Phần 2: Tổng quan về classes và kiến trúc MVC trong Odoo","uri":"https://hungpt.info/en/posts/odoo-javascript-classes-and-mvc-architecture_part2/"},{"content":"Trong Python, mixin đề cập đến như một lớp cung cấp các phương thức có thể được sử dụng lại.Tính năng này cũng có thể được sử dụng trong nền tảng Odoo. Bài viết này chúng ta sẽ thảo luận về cách sử dụng các class mixin trong Odoo 15.\nDưới đây mình có một ví dụ về 1 module trong đó có 3 đối tượng tương ứng với 3 model Teacher, Students, Parent. Trong đó mỗi đối tượng mình sẽ có 1 trường để lưu trữ ngày sinh và 1 trường lưu trữ tuổi được tự động tính từ trường ngày sinh. T\nTrong trường hợp này, phương thức tính tuổi từ ngày sinh được viết ở 3 chỗ tương ứng với 3 model, vì vậy ở đây chúng ta sẽ cần đến mixin để có thể tái sử dụng lại và không phải viết cùng 1 đoạn code ở nhiều chỗ khác nhau.\nStudent Model class Student(models.Model): _name = \u0026quot;student.student\u0026quot; _description = \u0026quot;Student\u0026quot; name = fields.Char(string=\u0026quot;Name\u0026quot;, required=True) partner_id = fields.Many2one('res.partner', string=\u0026quot;Partner\u0026quot;) phone = fields.Char(string=\u0026quot;Phone Number\u0026quot;) email = fields.Char(string=\u0026quot;Email\u0026quot;, required=True) status = fields.Char(string=\u0026quot;Status\u0026quot;) date = fields.Date(string=\u0026quot;Date\u0026quot;, default=fields.Date.today()) total_grade = fields.Float(string=\u0026quot;Total Grade\u0026quot;) dob = fields.Date(string=\u0026quot;DOB\u0026quot;) age = fields.Integer(string=\u0026quot;Age\u0026quot;, compute='_compute_age') Parent Model class Parent(models.Model): _name = \u0026quot;student.parent\u0026quot; _description = \u0026quot;Parent\u0026quot; name = fields.Char(string=\u0026quot;Name\u0026quot;, required=True) phone = fields.Char(string=\u0026quot;Phone Number\u0026quot;) email = fields.Char(string=\u0026quot;Email\u0026quot;) partner_id = fields.Many2one('res.partner', string=\u0026quot;Partner\u0026quot;, required=True) date = fields.Date(string=\u0026quot;Date\u0026quot;, default=fields.Date.today()) student_ids = fields.Many2many('student.student', string=\u0026quot;Students\u0026quot;) dob = fields.Date(string=\u0026quot;DOB\u0026quot;) age = fields.Integer(string=\u0026quot;Age\u0026quot;, compute='_compute_age') Teacher Model class Teacher(models.Model): _name = \u0026quot;teacher.teacher\u0026quot; _description = \u0026quot;Teacher\u0026quot; name = fields.Char(string=\u0026quot;Name\u0026quot;, required=True) phone = fields.Char(string=\u0026quot;Phone Number\u0026quot;) email = fields.Char(string=\u0026quot;Email\u0026quot;) partner_id = fields.Many2one('res.partner', string=\u0026quot;Partner\u0026quot;, required=True) date = fields.Date(string=\u0026quot;Date\u0026quot;, default=fields.Date.today()) student_ids = fields.Many2many('student.student', string=\u0026quot;Students\u0026quot;) dob = fields.Date(string=\u0026quot;DOB\u0026quot;) age = fields.Integer(string=\u0026quot;Age\u0026quot;, compute='_compute_age') Bây giờ chúng ta sẽ tạo ra 1 class mixin để viết phương thức tính tuổi từ ngày sinh như sau:\nMixin Class from odoo import fields from dateutil.relativedelta import relativedelta import logging _logger = logging.getLogger(__name__) class GetAgeMixin: def get_age_from_dob(self, dob): \u0026quot;\u0026quot;\u0026quot; :return: Returns age. \u0026quot;\u0026quot;\u0026quot; age = 0 today = fields.Date.today() if dob: age = relativedelta(today, dob).years return age Chúng ta sẽ kế thừa lại lớp Mixin này như sau:\nclass Student(models.Model, GetAgeMixin): _name = \u0026quot;student.student\u0026quot; _description = \u0026quot;Student\u0026quot; Và chúng ta sẽ viết hàm compute như sau:\n@api.depends('dob') def _compute_age(self): for rec in self: rec.age = self.get_age_from_dob(rec.dob) Tuy rằng ở ví dụ này, logic ở trong mixin không phức tạp, tuy nhiên với trường hợp thực tế đôi khi logic phức tạp khiến đoạn code xử lý rất dài, việc áp dụng mixin vào sẽ khiến chúng ta có cảm nhận rõ rệt hữu ích của nó mang lại\n","description":"","id":9,"section":"posts","tags":["Odoo15","OWL","Javascript"],"title":"Class Mixin là gì và Cách sử dụng class Mixin trong Odoo 15","uri":"https://hungpt.info/en/posts/what-is-mixin-class-how-to-use-mixin-classes-in-odoo-15/"},{"content":"Trong bài viết này, chúng ta sẽ đi qua những kiến thức cơ bản về Odoo JavaScript Framework với mục tiêu cuối cùng là tạo\nmột module trong OWL.\nKể từ Odoo 14 (và cả Odoo 15, 16), hệ thống JavaScript MVC cốt lõi trong Odoo vẫn chưa được viết lại bằng OWL. Vì vậy chúng ta sẽ tìm hiểu kiến trúc MVC của Odoo nhưng trước tiên, chúng ta phải xem xét 2 thành phần chính của các class trong JavaScript mà mọi phần đều được xây dựng dựa trên ‘web.Class’ và ‘web.Widget’.\nweb.Class trong Odoo Lớp web.js được định nghĩa trong odoo /addons/web/static/src/js/core/class.js là một đoạn code khá cũ\nViệc kế thừa các lớp trong javascript trong Odoo được viết như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  * @class Class */ function OdooClass(){} var initializing = false; var fnTest = /xyz/.test(function(){xyz();}) ? /\\b_super\\b/ : /.*/; /** * Subclass an existing class * * @param {Object} prop class-level properties (class attributes and instance methods) to set on the new class */ OdooClass.extend = function() { var _super = this.prototype; // Support mixins arguments  var args = _.toArray(arguments); args.unshift({}); var prop = _.extend.apply(_,args); // Instantiate a web class (but only create the instance,  // don\u0026#39;t run the init constructor)  initializing = true; var This = this; var prototype = new This(); initializing = false;   Điều này giúp Odoo có thể làm những việc như:\n1 2 3 4 5 6 7 8 9  var Class = require(\u0026#39;web.Class\u0026#39;); var mixins = require(\u0026#39;web.mixins\u0026#39;); var ServicesMixin = require(\u0026#39;web.ServicesMixin\u0026#39;); var MyCustomClass = core.Class.extend(mixins.PropertiesMixin, ServicesMixin, { myProperty: \u0026#39;test\u0026#39; // ... }   Kết luận lại thì Web.Class là thứ cho phép bạn thực hiện .extend() và .include trên mọi Widget JavaScript của Odoo, v.v.\nweb.Widget Odoo Class. Widget Class là lớp mở rộng của web.class kết hợp cùng với DOM thông qua Jquery và được định nghĩa trong /addons/web/static/src/js/core/widget.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var Widget = core.Class.extend(mixins.PropertiesMixin, ServicesMixin, { // Backbone-ish API  tagName: \u0026#39;div\u0026#39;, id: null, className: null, attributes: {}, events: {}, /** * The name of the QWeb template that will be used for rendering. Must be * redefined in subclasses or the default render() method can not be used. * * @type {null|string} */ template: null,   Bằng cách mở rộng web.class, Class Widget này có thể có 2 mixin, PropertiesMixin và ServicesMixin.\nweb.Widget extends the PropertiesMixin PropertiesMixin được cho là xử lý các thuộc tính(properties) tuy nhiên khi chúng ta xem code của mixin này:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  /** * @name PropertiesMixin * @mixin */ var PropertiesMixin = _.extend({}, EventDispatcherMixin, { init: function () { EventDispatcherMixin.init.call(this); this.__getterSetterInternalMap = {}; }, set: function (arg1, arg2, arg3) { var map; var options; if (typeof arg1 === \u0026#34;string\u0026#34;) { map = {}; map[arg1] = arg2; options = arg3 || {}; } else { map = arg1; options = arg2 || {}; } var self = this; var changed = false; _.each(map, function (val, key) { var tmp = self.__getterSetterInternalMap[key]; if (tmp === val) return; // seriously, why are you doing this? it is obviously a stupid design.  // the properties mixin should not be concerned with handling fields details.  // this also has the side effect of introducing a dependency on utils. Todo:  // remove this, or move it elsewhere. Also, learn OO programming.  if (key === \u0026#39;value\u0026#39; \u0026amp;\u0026amp; self.field \u0026amp;\u0026amp; self.field.type === \u0026#39;float\u0026#39; \u0026amp;\u0026amp; tmp \u0026amp;\u0026amp; val){ var digits = self.field.digits; if (_.isArray(digits)) { if (utils.float_is_zero(tmp - val, digits[1])) { return; } } } changed = true; self.__getterSetterInternalMap[key] = val; if (! options.silent) self.trigger(\u0026#34;change:\u0026#34; + key, self, { oldValue: tmp, newValue: val }); }); if (changed) self.trigger(\u0026#34;change\u0026#34;, self); }, get: function (key) { return this.__getterSetterInternalMap[key]; } }); return { ParentedMixin: ParentedMixin, EventDispatcherMixin: EventDispatcherMixin, PropertiesMixin: PropertiesMixin, };   PropertiesMixin lại extends EventDispatcherMixin, mục đích chính của PropertiesMixin đó chính là xử lý các trigger event trên UI\nCó một đoạn code khá hài hước mà hiện tại nó vẫn còn trong core của odoo\n1 2 3 4 5 6 7 8 9 10  _.each(map, function (val, key) { var tmp = self.__getterSetterInternalMap[key]; if (tmp === val) return; // seriously, why are you doing this? it is obviously a stupid design.  // the properties mixin should not be concerned with handling fields details.  // this also has the side effect of introducing a dependency on utils. Todo:  // remove this, or move it elsewhere. Also, learn OO programming.  if (key === \u0026#39;value\u0026#39; \u0026amp;\u0026amp; self.field \u0026amp;\u0026amp; self.field.type === \u0026#39;float\u0026#39; \u0026amp;\u0026amp; tmp \u0026amp;\u0026amp; val){ var digits = self.field.digits;   Also, learn OO programming. =)))\nBản thân EventDispatcherMixin cũng extend từ ParentedMixin do đó, nó cũng có thể gọi được các function như getParent hoặc getChildren\nweb.Widget extends the ServicesMixin Mixin này cung cấp cho Widget khả năng loadViews, do_action, get_session và thực hiện hàm RPC thông qua hàm _rpc.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183  odoo.define(\u0026#39;web.ServicesMixin\u0026#39;, function (require) { \u0026#34;use strict\u0026#34;; var rpc = require(\u0026#39;web.rpc\u0026#39;); /** * @mixin * @name ServicesMixin */ var ServicesMixin = { /** * @param {string} service * @param {string} method * @return {any} result of the service called */ call: function (service, method) { var args = Array.prototype.slice.call(arguments, 2); var result; this.trigger_up(\u0026#39;call_service\u0026#39;, { service: service, method: method, args: args, callback: function (r) { result = r; }, }); return result; }, /** * @private * @param {Object} libs - @see ajax.loadLibs * @param {Object} [context] - @see ajax.loadLibs * @param {Object} [tplRoute=this._loadLibsTplRoute] - @see ajax.loadLibs * @returns {Promise} */ _loadLibs: function (libs, context, tplRoute) { return this.call(\u0026#39;ajax\u0026#39;, \u0026#39;loadLibs\u0026#39;, libs, context, tplRoute || this._loadLibsTplRoute); }, /** * Builds and executes RPC query. Returns a promise resolved with * the RPC result. * * @param {string} params either a route or a model * @param {string} options if a model is given, this argument is a method * @returns {Promise} */ _rpc: function (params, options) { var query = rpc.buildQuery(params); var prom = this.call(\u0026#39;ajax\u0026#39;, \u0026#39;rpc\u0026#39;, query.route, query.params, options, this); if (!prom) { prom = new Promise(function () {}); prom.abort = function () {}; } var abort = prom.abort ? prom.abort : prom.reject; if (!abort) { throw new Error(\u0026#34;a rpc promise should always have a reject function\u0026#34;); } prom.abort = abort.bind(prom); return prom; }, loadFieldView: function (modelName, context, view_id, view_type, options) { return this.loadViews(modelName, context, [[view_id, view_type]], options).then(function (result) { return result[view_type]; }); }, loadViews: function (modelName, context, views, options) { var self = this; return new Promise(function (resolve) { self.trigger_up(\u0026#39;load_views\u0026#39;, { modelName: modelName, context: context, views: views, options: options, on_success: resolve, }); }); }, loadFilters: function (modelName, actionId, context) { var self = this; return new Promise(function (resolve, reject) { self.trigger_up(\u0026#39;load_filters\u0026#39;, { modelName: modelName, actionId: actionId, context: context, on_success: resolve, }); }); }, createFilter: function (filter) { var self = this; return new Promise(function (resolve, reject) { self.trigger_up(\u0026#39;create_filter\u0026#39;, { filter: filter, on_success: resolve, }); }); }, deleteFilter: function (filterId) { var self = this; return new Promise(function (resolve, reject) { self.trigger_up(\u0026#39;delete_filter\u0026#39;, { filterId: filterId, on_success: resolve, }); }); }, // Session stuff  getSession: function () { var session; this.trigger_up(\u0026#39;get_session\u0026#39;, { callback: function (result) { session = result; } }); return session; }, /** * Informs the action manager to do an action. This supposes that the action * manager can be found amongst the ancestors of the current widget. * If that\u0026#39;s not the case this method will simply return an unresolved * promise. * * @param {any} action * @param {any} options * @returns {Promise} */ do_action: function (action, options) { var self = this; return new Promise(function (resolve, reject) { self.trigger_up(\u0026#39;do_action\u0026#39;, { action: action, options: options, on_success: resolve, on_fail: reject, }); }); }, /** * Displays a notification. * * @param {Object} options * @param {string} options.title * @param {string} [options.subtitle] * @param {string} [options.message] * @param {string} [options.type=\u0026#39;warning\u0026#39;] \u0026#39;info\u0026#39;, \u0026#39;success\u0026#39;, \u0026#39;warning\u0026#39;, \u0026#39;danger\u0026#39; or \u0026#39;\u0026#39; * @param {boolean} [options.sticky=false] * @param {string} [options.className] */ displayNotification: function (options) { return this.call(\u0026#39;notification\u0026#39;, \u0026#39;notify\u0026#39;, options); }, /** * @deprecated will be removed as soon as the notification system is reviewed * @see displayNotification */ do_notify: function (title, message, sticky, className) { return this.displayNotification({ type: \u0026#39;warning\u0026#39;, title: title, message: message, sticky: sticky, className: className, }); }, /** * @deprecated will be removed as soon as the notification system is reviewed * @see displayNotification */ do_warn: function (title, message, sticky, className) { console.warn(title, message); return this.displayNotification({ type: \u0026#39;danger\u0026#39;, title: title, message: message, sticky: sticky, className: className,return }); }, }; return ServicesMixin; });   Ở function do_action chúng ta có thể thấy rằng bản chất vẫn là gọi đến hàm trigger_up, tuy nhiên mixin này lại không extend EventDispatcherMixin do đó để có thể dụng hết các function của mixin này bạn phải extend cả EventsDispatcherMixin vào class của bạn, khá là phiền phức nhỉ?😁\nOK, Hãy tóm tắt lại mớ hỗn độn này, vậy web.Widget có thể làm gì?😄 web.Widget có thể truy cập vào:\n ParentedMixin với các phương thức như getChildren, getParent… EventDispatcherMixin để kiểm soát các event thông qua trigger_up PropertiesMixin với get và set ServicesMixin với các phương thức như rpc, load_view… ","description":"","id":10,"section":"posts","tags":["Odoo","OWL","Javascript"],"title":"Odoo JavaScript - Phần 1: Tổng quan về classes và kiến trúc MVC trong Odoo","uri":"https://hungpt.info/en/posts/odoo-javascript-classes-and-mvc-architecture/"},{"content":"Fiber là gì? Fiber là một khung web lấy cảm hứng từ Express Web Framewok của NodeJs được xây dựng trên Fasthttp, công cụ HTTP nhanh nhất dành cho Go.\nĐược thiết kế để dễ dàng mọi thứ nhằm phát triển nhanh chóng mà không cần lưu ý đến hiệu suất và phân bổ bộ nhớ.\nCác tính năng của Fiber Framework  Robust routing / Định tuyến mạnh mẽ Serve static files / Cung cấp các tệp tĩnh Extreme performance . Hiệu suất cực cao Low memory footprint / Sử dụng bộ nhớ thấp API endpoints / Điểm cuối API Middleware \u0026amp; Next support Rapid server-side programming / Lập trình phía máy chủ nhanh chóng Template engines / Công cụ mẫu Hỗ trợ WebSocket Rate Limiter / Giới hạn tỷ lệ Được dịch sang 15 ngôn ngữ Và nhiều hơn nữa…  Set up the Project 1.Tạo thư mục\n1 2 3  $ mkdir Gofiber $ cd Gofiber   Khởi tạo project  1  $ go mod init github.com/\u0026lt;your GitHub username\u0026gt;/Gofiber   Tạo các thư mục cần thiết  1  $ mkdir service storage models   Install the Required Libraries 1.Cài đặt Gofiber\n1  $ go get -u github.com/gofiber/fiber/v2   Cài đặt Gorm  1  $ go get -u gorm.io/gorm   Install Gorm Postgres driver.  1  $ go get -u gorm.io/driver/postgres   Install Godotenv, used for loading environment variables.  1  $ go get github.com/joho/godotenv   Install Validator.  1  $ go get github.com/go-playground/validator/v10   Cài đặt database  Chuyển sang user postgres để thao tác  $ sudo -iu postgres psql Khởi tạo database  CREATE DATABASE gofiber; Exit  \\q Khởi tạo file .env và paste cấu hình sau  DB_HOST=localhost DB_PORT=5432 DB_USER=yourusername DB_PASS=yourpassword DB_NAME=gofiber DB_SSLMODE=disable Tạo file postgres.go và paste đoạn code sau  package storage import ( \u0026quot;fmt\u0026quot; \u0026quot;gorm.io/driver/postgres\u0026quot; \u0026quot;gorm.io/gorm\u0026quot; ) type Config struct { Host string Port string Password string User string DBName string SSLMode string } func NewConnection(config *Config) (*gorm.DB, error) { dsn := fmt.Sprintf( \u0026quot;host=%s port=%s user=%s password=%s dbname=%s sslmode=%s\u0026quot;, config.Host, config.Port, config.User, config.Password, config.DBName, config.SSLMode, ) db, err := gorm.Open(postgres.Open(dsn), \u0026amp;gorm.Config{}) if err != nil { return db, err } return db, nil } Tạo model Chúng ta sẽ tạo 1 folder models và tạo 1 file mới là books.go\npackage models import \u0026quot;gorm.io/gorm\u0026quot; type Books struct { ID uint `gorm:\u0026quot;primary key;autoIncrement\u0026quot; json:\u0026quot;id\u0026quot;` Author *string `json:\u0026quot;author\u0026quot;` Title *string `json:\u0026quot;title\u0026quot;` Publisher *string `json:\u0026quot;publisher\u0026quot;` } func MigrateBooks(db *gorm.DB) error { err := db.AutoMigrate(\u0026amp;Books{}) return err } Tạo service Mục đích để chúng ta xây dựng 1 cầu nối đứng giữa để kết nối tới Database\ntype Book struct { Author string `json:\u0026quot;author\u0026quot; validate:\u0026quot;required\u0026quot;` Title string `json:\u0026quot;title\u0026quot; validate:\u0026quot;required\u0026quot;` Publisher string `json:\u0026quot;publisher\u0026quot; validate:\u0026quot;required\u0026quot;` } type Repository struct { DB *gorm.DB } Ở đây mình đã tạo một cấu trúc để người dùng truyền lên.validate:required là thẻ sẽ được sử dụng để đảm bảo người dùng không bỏ qua bất kỳ trường nào khi tạo giá trị.\nSau bước này mình sẽ tạo các hàm thực hiện các chức năng như sau:\n Create books Update book by id Delete book by id Get all books Get books by id  Create Books func (r *Repository) CreateBook(context *fiber.Ctx) error { book := Book{} err := context.BodyParser(\u0026amp;book) if err != nil { context.Status(http.StatusUnprocessableEntity).JSON( \u0026amp;fiber.Map{\u0026quot;message\u0026quot;: \u0026quot;request failed\u0026quot;}) return err } validator := validator.New() err = validator.Struct(Book{}) if err != nil { context.Status(http.StatusUnprocessableEntity).JSON( \u0026amp;fiber.Map{\u0026quot;message\u0026quot;: err}, ) return err } err = r.DB.Create(\u0026amp;book).Error if err != nil { context.Status(http.StatusBadRequest).JSON( \u0026amp;fiber.Map{\u0026quot;message\u0026quot;: \u0026quot;could not create book\u0026quot;}) return err } context.Status(http.StatusOK).JSON(\u0026amp;fiber.Map{ \u0026quot;message\u0026quot;: \u0026quot;book has been successfully added\u0026quot;, }) return nil } Update Books by ID func (r *Repository) UpdateBook(context *fiber.Ctx) error { id := context.Params(\u0026quot;id\u0026quot;) if id == \u0026quot;\u0026quot; { context.Status(http.StatusInternalServerError).JSON(\u0026amp;fiber.Map{ \u0026quot;message\u0026quot;: \u0026quot;id cannot be empty\u0026quot;, }) return nil } bookModel := \u0026amp;models.Books{} book := Book{} err := context.BodyParser(\u0026amp;book) if err != nil { context.Status(http.StatusUnprocessableEntity).JSON( \u0026amp;fiber.Map{\u0026quot;message\u0026quot;: \u0026quot;request failed\u0026quot;}) return err } err = r.DB.Model(bookModel).Where(\u0026quot;id = ?\u0026quot;, id).Updates(book).Error if err != nil { context.Status(http.StatusBadRequest).JSON(\u0026amp;fiber.Map{ \u0026quot;message\u0026quot;: \u0026quot;could not update book\u0026quot;, }) return err } context.Status(http.StatusOK).JSON(\u0026amp;fiber.Map{ \u0026quot;message\u0026quot;: \u0026quot;book has been successfully updated\u0026quot;, }) return nil } Delete Book by ID func (r *Repository) DeleteBook(context *fiber.Ctx) error { bookModel := \u0026amp;models.Books{} id := context.Params(\u0026quot;id\u0026quot;) if id == \u0026quot;\u0026quot; { context.Status(http.StatusInternalServerError).JSON(\u0026amp;fiber.Map{ \u0026quot;message\u0026quot;: \u0026quot;id cannot be empty\u0026quot;, }) return nil } err := r.DB.Delete(bookModel, id) if err.Error != nil { context.Status(http.StatusBadRequest).JSON(\u0026amp;fiber.Map{ \u0026quot;message\u0026quot;: \u0026quot;could not delete book\u0026quot;, }) return err.Error } context.Status(http.StatusOK).JSON(\u0026amp;fiber.Map{ \u0026quot;message\u0026quot;: \u0026quot;book has been successfully deleted\u0026quot;, }) return nil Get All Books func (r *Repository) GetBooks(context *fiber.Ctx) error { bookModels := \u0026amp;[]models.Books{} err := r.DB.Find(bookModels).Error if err != nil { context.Status(http.StatusBadRequest).JSON( \u0026amp;fiber.Map{\u0026quot;message\u0026quot;: \u0026quot;could not get books\u0026quot;}) return err } context.Status(http.StatusOK).JSON(\u0026amp;fiber.Map{ \u0026quot;message\u0026quot;: \u0026quot;books gotten successfully\u0026quot;, \u0026quot;data\u0026quot;: bookModels, }) return nil } Get Books by ID func (r *Repository) GetBookByID(context *fiber.Ctx) error { id := context.Params(\u0026quot;id\u0026quot;) bookModel := \u0026amp;models.Books{} if id == \u0026quot;\u0026quot; { context.Status(http.StatusInternalServerError).JSON(\u0026amp;fiber.Map{ \u0026quot;message\u0026quot;: \u0026quot;id cannot be empty\u0026quot;, }) return nil } err := r.DB.Where(\u0026quot;id = ?\u0026quot;, id).First(bookModel).Error if err != nil { context.Status(http.StatusBadRequest).JSON( \u0026amp;fiber.Map{\u0026quot;message\u0026quot;: \u0026quot;could not get book\u0026quot;}) return err } context.Status(http.StatusOK).JSON(\u0026amp;fiber.Map{ \u0026quot;message\u0026quot;: \u0026quot;books id gotten successfully\u0026quot;, \u0026quot;data\u0026quot;: bookModel, }) return nil } Cài đặt Routes func (r *Repository) SetupRoutes(app *fiber.App) { api := app.Group(\u0026quot;/api\u0026quot;) api.Post(\u0026quot;/create_books\u0026quot;, r.CreateBook) api.Delete(\u0026quot;/delete_book/:id\u0026quot;, r.DeleteBook) api.Put(\u0026quot;/update_book/:id\u0026quot;, r.UpdateBook) api.Get(\u0026quot;/get_books/:id\u0026quot;, r.GetBookByID) api.Get(\u0026quot;/books\u0026quot;, r.GetBooks) } Tạo main function func main() { err := godotenv.Load(\u0026quot;.env\u0026quot;) if err != nil { log.Fatal(err) } config := \u0026amp;storage.Config{ Host: os.Getenv(\u0026quot;DB_HOST\u0026quot;), Port: os.Getenv(\u0026quot;DB_PORT\u0026quot;), Password: os.Getenv(\u0026quot;DB_PASS\u0026quot;), User: os.Getenv(\u0026quot;DB_USER\u0026quot;), SSLMode: os.Getenv(\u0026quot;DB_SSLMODE\u0026quot;), DBName: os.Getenv(\u0026quot;DB_NAME\u0026quot;), } db, err := storage.NewConnection(config) if err != nil { log.Fatal(\u0026quot;could not load database\u0026quot;) } err = models.MigrateBooks(db) if err != nil { log.Fatal(\u0026quot;could not migrate db\u0026quot;) } r := \u0026amp;service.Repository{ DB: db, } app := fiber.New() r.SetupRoutes(app) app.Listen(\u0026quot;:8080\u0026quot;) } Các bạn có tham khảo nhiều ví dụ, ứng dụng của Fiber Web Framework\n","description":"","id":11,"section":"posts","tags":["Golang"],"title":"Viết API sử dụng Fiber Framework + Postgresql trong Golang","uri":"https://hungpt.info/en/posts/api_golang_with_postgresql_part1/"},{"content":"Đối với lập trình viên odoo, Widget là một thứ khá mới mẻ bởi vì chúng ta hiếm khi lập trình với ngôn ngữ javascript.\nHầu như tất cả logic được viết với python, ngoại trừ khi tùy chỉnh điểm bán hàng(POS) hoặc mô-đun thương mại điện tử(Website).\nĐối với những lập trình viên odoo, theo cá nhân mình thấy thì javascript là phần cuối cùng mà bạn nên học. Tốt hơn hết bạn nên lập trung code với python\ntrừ khi dự án bạn làm liên quan đến POS hoặc Website\nĐối với odoo có 3 lĩnh vực chính mà javascript đc sử dụng, đó là POS, Website và Front-End.\nLưu ý : Phiên bản Odoo trong bài viết là Odoo13, với các phiên bản khác có thể sẽ không hoạt động ổn định.\nNhìn chung bạn không cần có quá nhiều kiến thức để bắt đầu với Widget, chỉ cần nắm vững được Javascript và Jquery. Javascript trong Odoo\nđược viết chủ yếu trong web/static/src/js/. Bạn có thể tham khảo tại đây odoo github page.\nTrong bài hướng dẫn đầu tiên này, mình sẽ tạo 1 Widget. Widget là 1 thành phần của Odoo, nó được dùng để hiển thị giá trị của một trường trong cơ sở dữ liệu. Ví dụ\nMany2many mặc định sẽ hiển thị dạng bảng, nhưng khi chúng ta sử dụng many2many_tags, dữ liệu sẽ hiển thị dạng từng component con một.\nĐể tạo một Widget, trước tiên bạn phải tạo 1 file javascript. Như ở đây, mình tạo 1 file là widget_one.js và lưu trữ tại thư mục your_module_name/static/src/js/.\nTrước tiên bạn phải chắc chắn widget_one.js đã được load trong odoo bằng câu lệnh sau:\n1  console.log(\u0026#39;hello world !\u0026#39;);   Tiếp theo chúng ta phải khai báo file javascript này trong một file xml là asset.xml (tên có thể tùy chỉnh)\n1 2 3 4 5 6 7 8 9 10  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;data\u0026gt; \u0026lt;template id=\u0026#34;tutorial_javascript_assets_backend\u0026#34; inherit_id=\u0026#34;web.assets_backend\u0026#34; name=\u0026#34;assets backend\u0026#34;\u0026gt; \u0026lt;xpath expr=\u0026#34;script[last()]\u0026#34; position=\u0026#34;after\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;/tutorial_javascript/static/src/js/widget_one.js\u0026#34;/\u0026gt; \u0026lt;/xpath\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/odoo\u0026gt;   Mục đích của việc này là kế thừa lại template web.assets_backend để khai báo thêm file javascipt của chúng ta. Điều này\nsẽ không ảnh hưởng đến phần javascipt phía module POS và module Website thương mại điện tử.\nSau đó thêm file xml phía trên vào file manifest.py, và khởi động lại service odoo, cài đặt module. Sau khi làm mới trình duyệt, F12 mở tab console bạn sẽ thấy như sau:\nTiếp theo khi mọi thứ đã hoạt động, chúng ta sẽ sửa lại file widget_one.js như sau:\n1 2 3 4 5 6  odoo.define(\u0026#39;tutorial_javascript.widget_one\u0026#39;, function (require) { \u0026#34;use strict\u0026#34;; console.log(\u0026#39;Place your widget code here\u0026#39;); });   Lưu ý, tất cả các Widget phải được mở rộng, hoặc là thành phần con của AbstractField cũng như được thêm vào field_registry. Vì vậy chúng ta sẽ viết tiếp như sau:\n1 2 3 4 5 6 7  odoo.define(\u0026#39;tutorial_javascript.widget_one\u0026#39;, function (require) { \u0026#34;use strict\u0026#34;; var AbstractField = require(\u0026#39;web.AbstractFields\u0026#39;); var FieldRegistry = require(\u0026#39;web.field_registry\u0026#39;); });   Trong bài viết này, mình sẽ tạo ra một widget đơn giản để hiện thị một đoạn thông tin ngắn. Để làm được việc này chúng ta có thể ghi đè các phương thức có sẵn như\n_render, _renderEdit, hoặc _renderReadonly.\nĐầu tiên chúng ta tạo 1 template mới với code như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;template\u0026gt; \u0026lt;t t-name=\u0026#34;WidgetOneTemplate\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;t t-if=\u0026#34;widget.mode == \u0026#39;edit\u0026#39; \u0026#34;\u0026gt; \u0026lt;p\u0026gt;This is the widget view in edit mode (the user is editing the document)\u0026lt;/p\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;t t-if=\u0026#34;widget.mode == \u0026#39;readonly\u0026#39; \u0026#34;\u0026gt; \u0026lt;p\u0026gt;This is the widget view in readonly mode (the user only sees the document)\u0026lt;/p\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/template\u0026gt;   Sau đó khai báo trong manifest.py như sau:\nSau đó mình sẽ viết 1 đoạn code cho widget này:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  odoo.define(\u0026#39;tutorial_javascript.widget_one\u0026#39;, function (require) { \u0026#34;use strict\u0026#34;; // import các đối tượng cần thiết để tạo widget  var AbstractField = require(\u0026#39;web.AbstractField\u0026#39;); var FieldRegistry = require(\u0026#39;web.field_registry\u0026#39;); // Tạo 1 object với tên tùy chỉnh  // đừng quyên kế thừa lại web.AbstractField  var WidgetOne = AbstractField.extend({ template: \u0026#39;WidgetOneTemplate\u0026#39;, // template chính là tên template chúng ta khai cái trong file xml  }); // đăng ký, nhúng object widget chúng ta vừa tạo vào web.field_registry object  // bây giờ chúng ta có thể sử dụng widget odoo\u0026#39;s view/xml file  // ví dụ với code như dưới đây  // \u0026lt;field name=\u0026#34;field_one\u0026#34; widget=\u0026#34;widget_one\u0026#34; /\u0026gt;  // the \u0026#39;widget_one\u0026#39; name is up to you, as long as it\u0026#39;s always connected/without spaces  FieldRegistry.add(\u0026#39;widget_one\u0026#39;, WidgetOne); // trả về widget object  // vì vậy chúng ta có thể kế thừa hoặc ghi đè trên các module khác  return WidgetOne; });   Đây là phần đầu tiên trong loạt bài Javascript trong Odoo, hy vọng bài viết sẽ giúp ích cho bạn 😀\n","description":"","id":12,"section":"posts","tags":["Odoo","OWL"],"title":"(Javascript trong Odoo) Phần 1 Tạo widget","uri":"https://hungpt.info/en/posts/odoo-javascript-programming-tutorial-part-one-create-widget-view/"},{"content":"Trong phần 1, chúng ta đã tạo ra 1 Widget để hiển thị một đoạn text văn bản. Sang phần 2 này, chúng ta cùng nhau xây dựng một logic cho widget này.\nTiếp theo bạn cần khai báo 1 trường như sau:\n1  field_one = fields.Integer(\u0026#39;Field One\u0026#39;)   Thông thường khi chúng ta khai báo 1 field như trên và thêm chúng vào XML, mặc định Odoo sẽ cho chúng ta sửa giá trị trên giao diện kiểu như sau:\nNhưng để có thể hạn chế thêm việc người dùng nhập vào không phải ký tự là số nguyên, ở đây mình sẽ thêm 2 nút tăng giảm + - và trường giá trị để readonly.\nDưới đây là đoạn code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;template\u0026gt; \u0026lt;t t-name=\u0026#34;WidgetOneTemplate\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;t t-if=\u0026#34;widget.mode == \u0026#39;edit\u0026#39; \u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;input-group\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;input-group-prepend\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-danger btn-minus\u0026#34;\u0026gt; - \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; t-att-value=\u0026#34;widget.value\u0026#34; disabled=\u0026#34;disabled\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;input-group-append\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-success btn-plus\u0026#34;\u0026gt; + \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;t t-if=\u0026#34;widget.mode == \u0026#39;readonly\u0026#39; \u0026#34;\u0026gt; \u0026lt;span t-esc=\u0026#34;widget.value\u0026#34; /\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/template\u0026gt;   Trong form ở chế độ chỉnh sửa sẽ như sau:\nSau đó, ở file widget_one.js mình sẽ tiến hành thêm event với 2 button là +-, dưới đây là đoạn code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var WidgetOne = AbstractField.extend({ template: \u0026#39;WidgetOneTemplate\u0026#39;, // fill with the template name that will be rendered by odoo  events: { // list of event, like jquery event  \u0026#39;click .btn-minus\u0026#39;: \u0026#39;btn_minus_action\u0026#39;, \u0026#39;click .btn-plus\u0026#39;: \u0026#39;btn_plus_action\u0026#39;, }, btn_minus_action: function(){ var new_value = this.value - 1; this._setValue(new_value.toString()); console.log(this.value); }, btn_plus_action: function(){ var new_value = this.value + 1; this._setValue(new_value.toString()); console.log(this.value); }, });   Các odoo viết sự kiện trong js cũng gần giống như jquery chỉ có điều là hơi đảo ngược 1 chút. Đối với jquery chúng ta sẽ viết như sau:\n1  $(\u0026#39;.btn-minus.\u0026#39;).click(btn_minus_action);   Thực tế chúng ta có thể sử dụng Jquery để thay thế cho đoạn code phía trên, tuy nhiên theo cá nhân mình thấy thì sử dụng code của Odoo sẽ dễ hiểu hơn.\nTuy nhiên nếu có cơ hội mình sẽ chia sẻ thêm về vấn đề này(cũng không phải là không có cách😄)\nĐể có thể thay đổi giá trị của field chúng ta có thể dùng phương thức this._setValue(new_value), nhưng chú ý kiểu dữ liệu của new_value, trong ví dụ của chúng ta\nbiến mà chúng ta truyền vào hàm _setValue phải là string. Thực ra mặc định không hẳn vậy, ví dụ khi chúng ta nhập giá trị vào ô input là 12345678, odoo hiểu ở đây là 1\nchuỗi string và tự động chuyển sang integer để cộng trừ nhân chia.\nVới đoạn code trên chúng ta cần chú ý toString(), tại sao chúng ta lại cần ép kiểu về string? Lý do mình đã giải thích bên trên, đơn giản là chúng ta cần phải ép kiểu\nvề như vậy\nOh, nhưng khoan đã! Tại sao giá trị field của chúng ta vẫn là 0 và không hề thay đổi.\nĐiều này chỉ ra rằng, khi chúng ta thực hiện thay đổi giá trị của field thì giao diện không tự động render lại.\nĐể có thể làm được điều này chúng ta cần phải override lại phương thức _render hoặc _renderEdit. Trong ví dụ của chúng ta, mình sẽ override lại hàm _render.\nCó nhiều cách để thay đổi giao diện người dùng (mình sẽ đề cập trong 1 bài viết sớm), tuy nhiên ở đây mình sẽ dùng qweb và viết nó vào trong hàm _render như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  odoo.define(\u0026#39;tutorial_javascript.widget_one\u0026#39;, function (require) { \u0026#34;use strict\u0026#34;; var AbstractField = require(\u0026#39;web.AbstractField\u0026#39;); var FieldRegistry = require(\u0026#39;web.field_registry\u0026#39;); var core = require(\u0026#39;web.core\u0026#39;); var qweb = core.qweb; var WidgetOne = AbstractField.extend({ template: \u0026#39;WidgetOneTemplate\u0026#39;, events: { \u0026#39;click .btn-minus\u0026#39;: \u0026#39;btn_minus_action\u0026#39;, \u0026#39;click .btn-plus\u0026#39;: \u0026#39;btn_plus_action\u0026#39;, }, btn_minus_action: function(){ var new_value = this.value - 1; this._setValue(new_value.toString()); }, btn_plus_action: function(){ var new_value = this.value + 1; this._setValue(new_value.toString()); }, _render: function () { console.log(this.value); this.$el.html($(qweb.render(this.template, {\u0026#39;widget\u0026#39;: this}))); }, }); FieldRegistry.add(\u0026#39;widget_one\u0026#39;, WidgetOne); return WidgetOne; });   Tham số đầu tiên mà mình truyền vào qweb.render() đó là template mà chúng ta muốn render lại, tham số thứ 2 ở đây chính là widget của chúng ta, khi thay đổi giá trị của field\n,ở đây là widget do chúng ta đã viết nó trong xml như bên dưới:\nRestart Odoo, refresh trình duyệt chúng ta thấy rằng mọi thứ đã chạy chính xác!\nĐây là phần hai trong loạt bài Javascript trong Odoo, hy vọng bài viết sẽ giúp ích cho bạn 😀\n","description":"","id":13,"section":"posts","tags":["Odoo","OWL"],"title":"(Javascript trong Odoo) Phần 2 Tạo logic cho widget","uri":"https://hungpt.info/en/posts/odoo-javascript-programming-tutorial-part-two-widget-logic/"},{"content":"Trước tiên chúng ta hãy cùng nói lại về khái niệm Template trong Ansible và tại sao chúng ta phải dùng nó\nNhu cầu rất đơn giản, cùng một file cấu hình của một phần mềm nhưng khi triển khai trên các server khác nhau thì lại cần cấu hình IP khác nhau? Với Jinja2 template, Ansible sẽ không những giải quyết được mà còn làm rất tốt việc đó vì Jina2 template rất dễ đọc và dễ tiếp cận\nAnsible sử dụng các file Template Jinja2 để đưa các nội dung động như giá trị các biến(IP, hostname, version…) vào file template\n","description":"","id":16,"section":"posts","tags":["Devops","Ansible","AWS"],"title":"[Dành cho Beginner] Phần 3: Template trong Ansible","uri":"https://hungpt.info/en/posts/template_in_ansible/"},{"content":"Trước tiên chúng ta hãy cùng nói lại về khái niệm Playbook trong Ansible\nVề Playbook Playbook thông thường là những tấm bảng ghi sơ đồ vị trí, chiến thuật di chuyển của từng cầu thủ mà các HLV sử dụng để truyền đạt cho cầu thủ (nếu bạn xem đá bóng). Ví dụ như Công Phượng đá hộ công, Huy Toàn đột phá cánh trái hay Quế Ngọc Hải đá hậu vệ.\nAnsible sử dụng khái niệm Playbook cũng mang ý nghĩa tương tự. Việc triển khai hệ thống mới cũng tương tự như sơ đồ chiến thuật, các group [webservers], [databases] cũng như tuyến tiền đạo, hậu vệ, các dịch vụ cũng như kết nối tới các thành phần khác nhau trong hệ thống của từng server cũng giống nhiệm vụ của một cầu thủ trên sân.\nThực hành Tiếp theo chúng ta hãy cùng thực hành luôn nhé!\nMô hình bài lab vẫn như bài trước, chúng ta sẽ có 3 máy ảo EC2 trên AWS, cài đặt Ansible cho 1 máy EC2 ubuntu\nĐể in ra thông tin trong quá trình chạy Playbook, chúng ta sẽ sử dụng module Debug trong Ansible. Để hiển thị thôn tin debug có 2 phương án phổ biến là: mgs và var. Vẫn trong thư mục websrv chúng ta đã tạo ở bài trước với file host, tạo thêm 1 file PlaybookVar.yaml sau đó đưa nội dung sau vào:\n--- - name: Test variable hosts: webserver gather_facts: true tasks: - name: \u0026quot;Show target server IP\u0026quot; debug: msg: “Target system (Web server) IP= {{inventory_hostname}}” #var: inventory_hostname Save lại và chạy lệnh:\n1  ansible-playbook -i hosts playbookVar.yml   Chúng ta có thể định nghĩa biến ngay trong file Playbook như sau, biến khai báo trùng tên trong file hosts và trong Playbook thì Ansible ưu tiên trong playbook hơn :\n--- - name: Test variable hosts: webserver gather_facts: true tasks: - name: \u0026quot;Show NTP Server Infor\u0026quot; debug: # msg: “Target system (Web server) IP= {{inventory_hostname}}” var: ntp_server_test, ntp_port_test vars: ntp_server_test: 192.168.11.1 ntp_port_test: \u0026quot;UDP 1313\u0026quot; Chúng ta sẽ có kết quả như sau:\nHoặc chúng ta cũng có thể định nghĩa biến trong file riêng:\n Tạo thư mục chứa các file khai báo biến riêng : mkdir vars \u0026amp;\u0026amp; cd vars Tạo file chứa các biến khi cài DB server và viết nội dung sau:  mysqlservice: mysqld mysql_port: 3306 db_user: foouser upassword: abc Tiếp theo chúng ta sẽ hiệu chỉnh lại file playbook để import file chứa biến riêng và hiển thị giá trị của các biến:\n--- - name: Test variable hosts: webserver gather_facts: true tasks: - name: \u0026quot;Show NTP Server Infor\u0026quot; debug: # msg: “Target system (Web server) IP= {{inventory_hostname}}” var: ntp_server['IP'], httpd_port[1], mysql_port vars: ntp_server: IP: 192.168.122.1 ntp_port: \u0026quot;UDP 1312\u0026quot; httpd_port: - 80 - 443 vars_files: - ./vars/dbserver Sau đó chạy lệnh ansible-playbook -i hosts playbookvar.yaml để phân tích đâu là biến kiểu Array, đâu là kiểu Object\nChúng ta cũng có thể in các giá trị của biến OUTPUT từ lệnh khác như sau:\n--- - name: Test variable hosts: webserver gather_facts: true tasks: - name: \u0026quot;Show NTP Server Infor\u0026quot; debug: # msg: “Target system (Web server) IP= {{inventory_hostname}}” var: ntp_server['IP'], httpd_port[1], mysql_port - name: Check uptime target server shell: uptime register: output - name: \u0026quot;Show uptime from shell\u0026quot; debug: var: output vars: ntp_server: IP: 192.168.122.1 ntp_port: \u0026quot;UDP 1312\u0026quot; httpd_port: - 80 - 443 vars_files: - ./vars/dbserver Sau đó chạy thử, chúng ta sẽ thấy biến uptime trong mục “stdout_lines”\nTiếp theo chúng ta có thể đọc dữ liệu từ các biến Built-in của Ansible. Khi Ansible bắt đầu chạy Playbook, mặc định nó sẽ đọc các thông số của Target server vào biến môi trường gọi là Facts\nChúng ta sẽ tạo 1 playbook mới và viết nội dung như sau:\n--- - hosts: webserver gather_facts: true tasks: - name: \u0026quot;Show ansiblr Facts\u0026quot; debug: var: ansible_facts Sau đó chúng ta chạy lệnh sẽ được kết quả như sau:\nubuntu@ip-10-32-1-210:~/websrv$ ansible-playbook -i hosts playbookFacts.yaml PLAY [webserver] *************************************************************** TASK [Gathering Facts] ********************************************************* [WARNING]: Platform linux on host 16.163.95.41 is using the discovered Python interpreter at /usr/bin/python, but future installation of another Python interpreter could change this. See https://docs.ansible.com/ansible/2.9/referen ce_appendices/interpreter_discovery.html for more information. ok: [16.163.95.41] TASK [Show ansiblr Facts] ****************************************************** ok: [16.163.95.41] =\u0026gt; { \u0026quot;ansible_facts\u0026quot;: { \u0026quot;_facts_gathered\u0026quot;: true, \u0026quot;all_ipv4_addresses\u0026quot;: [ \u0026quot;10.32.1.186\u0026quot; ], \u0026quot;all_ipv6_addresses\u0026quot;: [ \u0026quot;fe80::42d:d5ff:fef3:7b08\u0026quot; ], \u0026quot;ansible_local\u0026quot;: {}, \u0026quot;apparmor\u0026quot;: { \u0026quot;status\u0026quot;: \u0026quot;disabled\u0026quot; }, \u0026quot;architecture\u0026quot;: \u0026quot;x86_64\u0026quot;, \u0026quot;bios_date\u0026quot;: \u0026quot;10/16/2017\u0026quot;, \u0026quot;bios_version\u0026quot;: \u0026quot;1.0\u0026quot;, \u0026quot;cmdline\u0026quot;: { \u0026quot;BOOT_IMAGE\u0026quot;: \u0026quot;/boot/vmlinuz-5.10.135-122.509.amzn2.x86_64\u0026quot;, \u0026quot;biosdevname\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;console\u0026quot;: \u0026quot;ttyS0,115200n8\u0026quot;, \u0026quot;net.ifnames\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;nvme_core.io_timeout\u0026quot;: \u0026quot;4294967295\u0026quot;, \u0026quot;rd.emergency\u0026quot;: \u0026quot;poweroff\u0026quot;, \u0026quot;rd.shell\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;ro\u0026quot;: true, \u0026quot;root\u0026quot;: \u0026quot;UUID=2318d4b7-b8cd-4579-ab46-47af13e15000\u0026quot; }, \u0026quot;date_time\u0026quot;: { \u0026quot;date\u0026quot;: \u0026quot;2022-10-15\u0026quot;, \u0026quot;day\u0026quot;: \u0026quot;15\u0026quot;, \u0026quot;epoch\u0026quot;: \u0026quot;1665854220\u0026quot;, \u0026quot;hour\u0026quot;: \u0026quot;17\u0026quot;, \u0026quot;iso8601\u0026quot;: \u0026quot;2022-10-15T17:17:00Z\u0026quot;, \u0026quot;iso8601_basic\u0026quot;: \u0026quot;20221015T171700106679\u0026quot;, \u0026quot;iso8601_basic_short\u0026quot;: \u0026quot;20221015T171700\u0026quot;, \u0026quot;iso8601_micro\u0026quot;: \u0026quot;2022-10-15T17:17:00.106749Z\u0026quot;, \u0026quot;minute\u0026quot;: \u0026quot;17\u0026quot;, \u0026quot;month\u0026quot;: \u0026quot;10\u0026quot;, \u0026quot;second\u0026quot;: \u0026quot;00\u0026quot;, \u0026quot;time\u0026quot;: \u0026quot;17:17:00\u0026quot;, \u0026quot;tz\u0026quot;: \u0026quot;UTC\u0026quot;, \u0026quot;tz_offset\u0026quot;: \u0026quot;+0000\u0026quot;, \u0026quot;weekday\u0026quot;: \u0026quot;Saturday\u0026quot;, \u0026quot;weekday_number\u0026quot;: \u0026quot;6\u0026quot;, \u0026quot;weeknumber\u0026quot;: \u0026quot;41\u0026quot;, \u0026quot;year\u0026quot;: \u0026quot;2022\u0026quot; }, \u0026quot;default_ipv4\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;10.32.1.186\u0026quot;, \u0026quot;alias\u0026quot;: \u0026quot;eth0\u0026quot;, \u0026quot;broadcast\u0026quot;: \u0026quot;10.32.1.255\u0026quot;, \u0026quot;gateway\u0026quot;: \u0026quot;10.32.1.1\u0026quot;, \u0026quot;interface\u0026quot;: \u0026quot;eth0\u0026quot;, \u0026quot;macaddress\u0026quot;: \u0026quot;06:2d:d5:f3:7b:08\u0026quot;, \u0026quot;mtu\u0026quot;: 9001, \u0026quot;netmask\u0026quot;: \u0026quot;255.255.255.0\u0026quot;, \u0026quot;network\u0026quot;: \u0026quot;10.32.1.0\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;ether\u0026quot; }, \u0026quot;default_ipv6\u0026quot;: {}, \u0026quot;device_links\u0026quot;: { \u0026quot;ids\u0026quot;: { \u0026quot;nvme0n1\u0026quot;: [ \u0026quot;nvme-Amazon_Elastic_Block_Store_vol04b1c50673dda9abc\u0026quot;, \u0026quot;nvme-Amazon_Elastic_Block_Store_vol04b1c50673dda9abc-ns-1\u0026quot;, \u0026quot;nvme-nvme.1d0f-766f6c3034623163353036373364646139616263-416d617a6f6e20456c617374696320426c6f636b2053746f7265-00000001\u0026quot; ], \u0026quot;nvme0n1p1\u0026quot;: [ \u0026quot;nvme-Amazon_Elastic_Block_Store_vol04b1c50673dda9abc-ns-1-part1\u0026quot;, \u0026quot;nvme-Amazon_Elastic_Block_Store_vol04b1c50673dda9abc-part1\u0026quot;, \u0026quot;nvme-nvme.1d0f-766f6c3034623163353036373364646139616263-416d617a6f6e20456c617374696320426c6f636b2053746f7265-00000001-part1\u0026quot; ], \u0026quot;nvme0n1p128\u0026quot;: [ \u0026quot;nvme-Amazon_Elastic_Block_Store_vol04b1c50673dda9abc-ns-1-part128\u0026quot;, \u0026quot;nvme-Amazon_Elastic_Block_Store_vol04b1c50673dda9abc-part128\u0026quot;, \u0026quot;nvme-nvme.1d0f-766f6c3034623163353036373364646139616263-416d617a6f6e20456c617374696320426c6f636b2053746f7265-00000001-part128\u0026quot; ] }, \u0026quot;labels\u0026quot;: { \u0026quot;nvme0n1p1\u0026quot;: [ \u0026quot;\\\\x2f\u0026quot; ] }, \u0026quot;masters\u0026quot;: {}, \u0026quot;uuids\u0026quot;: { \u0026quot;nvme0n1p1\u0026quot;: [ \u0026quot;2318d4b7-b8cd-4579-ab46-47af13e15000\u0026quot; ] } }, \u0026quot;devices\u0026quot;: { \u0026quot;nvme0n1\u0026quot;: { \u0026quot;holders\u0026quot;: [], \u0026quot;host\u0026quot;: \u0026quot;Non-Volatile memory controller: Amazon.com, Inc. Device 8061\u0026quot;, \u0026quot;links\u0026quot;: { \u0026quot;ids\u0026quot;: [ \u0026quot;nvme-Amazon_Elastic_Block_Store_vol04b1c50673dda9abc\u0026quot;, \u0026quot;nvme-Amazon_Elastic_Block_Store_vol04b1c50673dda9abc-ns-1\u0026quot;, \u0026quot;nvme-nvme.1d0f-766f6c3034623163353036373364646139616263-416d617a6f6e20456c617374696320426c6f636b2053746f7265-00000001\u0026quot; ], \u0026quot;labels\u0026quot;: [], \u0026quot;masters\u0026quot;: [], \u0026quot;uuids\u0026quot;: [] }, \u0026quot;model\u0026quot;: \u0026quot;Amazon Elastic Block Store\u0026quot;, \u0026quot;partitions\u0026quot;: { \u0026quot;nvme0n1p1\u0026quot;: { \u0026quot;holders\u0026quot;: [], \u0026quot;links\u0026quot;: { \u0026quot;ids\u0026quot;: [ \u0026quot;nvme-Amazon_Elastic_Block_Store_vol04b1c50673dda9abc-ns-1-part1\u0026quot;, \u0026quot;nvme-Amazon_Elastic_Block_Store_vol04b1c50673dda9abc-part1\u0026quot;, \u0026quot;nvme-nvme.1d0f-766f6c3034623163353036373364646139616263-416d617a6f6e20456c617374696320426c6f636b2053746f7265-00000001-part1\u0026quot; ], \u0026quot;labels\u0026quot;: [ \u0026quot;\\\\x2f\u0026quot; ], \u0026quot;masters\u0026quot;: [], \u0026quot;uuids\u0026quot;: [ \u0026quot;2318d4b7-b8cd-4579-ab46-47af13e15000\u0026quot; ] }, \u0026quot;sectors\u0026quot;: \u0026quot;16773087\u0026quot;, \u0026quot;sectorsize\u0026quot;: 512, \u0026quot;size\u0026quot;: \u0026quot;8.00 GB\u0026quot;, \u0026quot;start\u0026quot;: \u0026quot;4096\u0026quot;, \u0026quot;uuid\u0026quot;: \u0026quot;2318d4b7-b8cd-4579-ab46-47af13e15000\u0026quot; }, \u0026quot;nvme0n1p128\u0026quot;: { \u0026quot;holders\u0026quot;: [], \u0026quot;links\u0026quot;: { \u0026quot;ids\u0026quot;: [ \u0026quot;nvme-Amazon_Elastic_Block_Store_vol04b1c50673dda9abc-ns-1-part128\u0026quot;, \u0026quot;nvme-Amazon_Elastic_Block_Store_vol04b1c50673dda9abc-part128\u0026quot;, \u0026quot;nvme-nvme.1d0f-766f6c3034623163353036373364646139616263-416d617a6f6e20456c617374696320426c6f636b2053746f7265-00000001-part128\u0026quot; ], \u0026quot;labels\u0026quot;: [], \u0026quot;masters\u0026quot;: [], \u0026quot;uuids\u0026quot;: [] }, \u0026quot;sectors\u0026quot;: \u0026quot;2048\u0026quot;, \u0026quot;sectorsize\u0026quot;: 512, \u0026quot;size\u0026quot;: \u0026quot;1.00 MB\u0026quot;, \u0026quot;start\u0026quot;: \u0026quot;2048\u0026quot;, \u0026quot;uuid\u0026quot;: null } }, \u0026quot;removable\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;rotational\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;sas_address\u0026quot;: null, \u0026quot;sas_device_handle\u0026quot;: null, \u0026quot;scheduler_mode\u0026quot;: \u0026quot;none\u0026quot;, \u0026quot;sectors\u0026quot;: \u0026quot;16777216\u0026quot;, \u0026quot;sectorsize\u0026quot;: \u0026quot;512\u0026quot;, \u0026quot;size\u0026quot;: \u0026quot;8.00 GB\u0026quot;, \u0026quot;support_discard\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;vendor\u0026quot;: null, \u0026quot;virtual\u0026quot;: 1 } }, \u0026quot;discovered_interpreter_python\u0026quot;: \u0026quot;/usr/bin/python\u0026quot;, \u0026quot;distribution\u0026quot;: \u0026quot;Amazon\u0026quot;, \u0026quot;distribution_file_parsed\u0026quot;: true, \u0026quot;distribution_file_path\u0026quot;: \u0026quot;/etc/system-release\u0026quot;, \u0026quot;distribution_file_variety\u0026quot;: \u0026quot;Amazon\u0026quot;, \u0026quot;distribution_major_version\u0026quot;: \u0026quot;2\u0026quot;, \u0026quot;distribution_release\u0026quot;: \u0026quot;NA\u0026quot;, \u0026quot;distribution_version\u0026quot;: \u0026quot;2\u0026quot;, \u0026quot;dns\u0026quot;: { \u0026quot;nameservers\u0026quot;: [ \u0026quot;10.32.0.2\u0026quot; ], \u0026quot;options\u0026quot;: { \u0026quot;attempts\u0026quot;: \u0026quot;5\u0026quot;, \u0026quot;timeout\u0026quot;: \u0026quot;2\u0026quot; }, \u0026quot;search\u0026quot;: [ \u0026quot;ap-east-1.compute.internal\u0026quot; ] }, \u0026quot;domain\u0026quot;: \u0026quot;ap-east-1.compute.internal\u0026quot;, \u0026quot;effective_group_id\u0026quot;: 1000, \u0026quot;effective_user_id\u0026quot;: 1000, \u0026quot;env\u0026quot;: { \u0026quot;HOME\u0026quot;: \u0026quot;/home/ec2-user\u0026quot;, \u0026quot;LANG\u0026quot;: \u0026quot;C.UTF-8\u0026quot;, \u0026quot;LC_ADDRESS\u0026quot;: \u0026quot;C.UTF-8\u0026quot;, \u0026quot;LC_IDENTIFICATION\u0026quot;: \u0026quot;C.UTF-8\u0026quot;, \u0026quot;LC_MEASUREMENT\u0026quot;: \u0026quot;C.UTF-8\u0026quot;, \u0026quot;LC_MONETARY\u0026quot;: \u0026quot;C.UTF-8\u0026quot;, \u0026quot;LC_NAME\u0026quot;: \u0026quot;C.UTF-8\u0026quot;, \u0026quot;LC_NUMERIC\u0026quot;: \u0026quot;C.UTF-8\u0026quot;, \u0026quot;LC_PAPER\u0026quot;: \u0026quot;C.UTF-8\u0026quot;, \u0026quot;LC_TELEPHONE\u0026quot;: \u0026quot;C.UTF-8\u0026quot;, \u0026quot;LC_TIME\u0026quot;: \u0026quot;C.UTF-8\u0026quot;, \u0026quot;LESSOPEN\u0026quot;: \u0026quot;||/usr/bin/lesspipe.sh %s\u0026quot;, \u0026quot;LOGNAME\u0026quot;: \u0026quot;ec2-user\u0026quot;, \u0026quot;LS_COLORS\u0026quot;: \u0026quot;rs=0:di=38;5;27:ln=38;5;51:mh=44;38;5;15:pi=40;38;5;11:so=38;5;13:do=38;5;5:bd=48;5;232;38;5;11:cd=48;5;232;38;5;3:or=48;5;232;38;5;9:mi=05;48;5;232;38;5;15:su=48;5;196;38;5;15:sg=48;5;11;38;5;16:ca=48;5;196;38;5;226:tw=48;5;10;38;5;16:ow=48;5;10;38;5;21:st=48;5;21;38;5;15:ex=38;5;34:*.tar=38;5;9:*.tgz=38;5;9:*.arc=38;5;9:*.arj=38;5;9:*.taz=38;5;9:*.lha=38;5;9:*.lz4=38;5;9:*.lzh=38;5;9:*.lzma=38;5;9:*.tlz=38;5;9:*.txz=38;5;9:*.tzo=38;5;9:*.t7z=38;5;9:*.zip=38;5;9:*.z=38;5;9:*.Z=38;5;9:*.dz=38;5;9:*.gz=38;5;9:*.lrz=38;5;9:*.lz=38;5;9:*.lzo=38;5;9:*.xz=38;5;9:*.bz2=38;5;9:*.bz=38;5;9:*.tbz=38;5;9:*.tbz2=38;5;9:*.tz=38;5;9:*.deb=38;5;9:*.rpm=38;5;9:*.jar=38;5;9:*.war=38;5;9:*.ear=38;5;9:*.sar=38;5;9:*.rar=38;5;9:*.alz=38;5;9:*.ace=38;5;9:*.zoo=38;5;9:*.cpio=38;5;9:*.7z=38;5;9:*.rz=38;5;9:*.cab=38;5;9:*.jpg=38;5;13:*.jpeg=38;5;13:*.gif=38;5;13:*.bmp=38;5;13:*.pbm=38;5;13:*.pgm=38;5;13:*.ppm=38;5;13:*.tga=38;5;13:*.xbm=38;5;13:*.xpm=38;5;13:*.tif=38;5;13:*.tiff=38;5;13:*.png=38;5;13:*.svg=38;5;13:*.svgz=38;5;13:*.mng=38;5;13:*.pcx=38;5;13:*.mov=38;5;13:*.mpg=38;5;13:*.mpeg=38;5;13:*.m2v=38;5;13:*.mkv=38;5;13:*.webm=38;5;13:*.ogm=38;5;13:*.mp4=38;5;13:*.m4v=38;5;13:*.mp4v=38;5;13:*.vob=38;5;13:*.qt=38;5;13:*.nuv=38;5;13:*.wmv=38;5;13:*.asf=38;5;13:*.rm=38;5;13:*.rmvb=38;5;13:*.flc=38;5;13:*.avi=38;5;13:*.fli=38;5;13:*.flv=38;5;13:*.gl=38;5;13:*.dl=38;5;13:*.xcf=38;5;13:*.xwd=38;5;13:*.yuv=38;5;13:*.cgm=38;5;13:*.emf=38;5;13:*.axv=38;5;13:*.anx=38;5;13:*.ogv=38;5;13:*.ogx=38;5;13:*.aac=38;5;45:*.au=38;5;45:*.flac=38;5;45:*.mid=38;5;45:*.midi=38;5;45:*.mka=38;5;45:*.mp3=38;5;45:*.mpc=38;5;45:*.ogg=38;5;45:*.ra=38;5;45:*.wav=38;5;45:*.axa=38;5;45:*.oga=38;5;45:*.spx=38;5;45:*.xspf=38;5;45:\u0026quot;, \u0026quot;MAIL\u0026quot;: \u0026quot;/var/mail/ec2-user\u0026quot;, \u0026quot;PATH\u0026quot;: \u0026quot;/usr/local/bin:/usr/bin\u0026quot;, \u0026quot;PWD\u0026quot;: \u0026quot;/home/ec2-user\u0026quot;, \u0026quot;SHELL\u0026quot;: \u0026quot;/bin/bash\u0026quot;, \u0026quot;SHLVL\u0026quot;: \u0026quot;2\u0026quot;, \u0026quot;SSH_CLIENT\u0026quot;: \u0026quot;18.162.41.145 50404 22\u0026quot;, \u0026quot;SSH_CONNECTION\u0026quot;: \u0026quot;18.162.41.145 50404 10.32.1.186 22\u0026quot;, \u0026quot;SSH_TTY\u0026quot;: \u0026quot;/dev/pts/0\u0026quot;, \u0026quot;TERM\u0026quot;: \u0026quot;xterm-256color\u0026quot;, \u0026quot;USER\u0026quot;: \u0026quot;ec2-user\u0026quot;, \u0026quot;XDG_RUNTIME_DIR\u0026quot;: \u0026quot;/run/user/1000\u0026quot;, \u0026quot;XDG_SESSION_ID\u0026quot;: \u0026quot;34\u0026quot;, \u0026quot;_\u0026quot;: \u0026quot;/usr/bin/python\u0026quot; }, \u0026quot;eth0\u0026quot;: { \u0026quot;active\u0026quot;: true, \u0026quot;device\u0026quot;: \u0026quot;eth0\u0026quot;, \u0026quot;features\u0026quot;: { \u0026quot;esp_hw_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;esp_tx_csum_hw_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;fcoe_mtu\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;generic_receive_offload\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;generic_segmentation_offload\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;highdma\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;hw_tc_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;l2_fwd_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;large_receive_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;loopback\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;macsec_hw_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;netns_local\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;ntuple_filters\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;receive_hashing\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;rx_all\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_checksumming\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_fcs\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_gro_hw\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_gro_list\u0026quot;: \u0026quot;off\u0026quot;, \u0026quot;rx_udp_tunnel_port_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_vlan_filter\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_vlan_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_vlan_stag_filter\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_vlan_stag_hw_parse\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;scatter_gather\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;tcp_segmentation_offload\u0026quot;: \u0026quot;off\u0026quot;, \u0026quot;tls_hw_record\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tls_hw_rx_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tls_hw_tx_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_checksum_fcoe_crc\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_checksum_ip_generic\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_checksum_ipv4\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;tx_checksum_ipv6\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_checksum_sctp\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_checksumming\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;tx_esp_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_fcoe_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_gre_csum_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_gre_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_gso_list\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_gso_partial\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_gso_robust\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_ipxip4_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_ipxip6_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_lockless\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_nocache_copy\u0026quot;: \u0026quot;off\u0026quot;, \u0026quot;tx_scatter_gather\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;tx_scatter_gather_fraglist\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_sctp_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_tcp6_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_tcp_ecn_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_tcp_mangleid_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_tcp_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_tunnel_remcsum_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_udp_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_udp_tnl_csum_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_udp_tnl_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_vlan_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_vlan_stag_hw_insert\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;udp_fragmentation_offload\u0026quot;: \u0026quot;off\u0026quot;, \u0026quot;vlan_challenged\u0026quot;: \u0026quot;off [fixed]\u0026quot; }, \u0026quot;hw_timestamp_filters\u0026quot;: [], \u0026quot;ipv4\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;10.32.1.186\u0026quot;, \u0026quot;broadcast\u0026quot;: \u0026quot;10.32.1.255\u0026quot;, \u0026quot;netmask\u0026quot;: \u0026quot;255.255.255.0\u0026quot;, \u0026quot;network\u0026quot;: \u0026quot;10.32.1.0\u0026quot; }, \u0026quot;ipv6\u0026quot;: [ { \u0026quot;address\u0026quot;: \u0026quot;fe80::42d:d5ff:fef3:7b08\u0026quot;, \u0026quot;prefix\u0026quot;: \u0026quot;64\u0026quot;, \u0026quot;scope\u0026quot;: \u0026quot;link\u0026quot; } ], \u0026quot;macaddress\u0026quot;: \u0026quot;06:2d:d5:f3:7b:08\u0026quot;, \u0026quot;module\u0026quot;: \u0026quot;ena\u0026quot;, \u0026quot;mtu\u0026quot;: 9001, \u0026quot;pciid\u0026quot;: \u0026quot;0000:00:05.0\u0026quot;, \u0026quot;promisc\u0026quot;: false, \u0026quot;timestamping\u0026quot;: [ \u0026quot;tx_software\u0026quot;, \u0026quot;rx_software\u0026quot;, \u0026quot;software\u0026quot; ], \u0026quot;type\u0026quot;: \u0026quot;ether\u0026quot; }, \u0026quot;fibre_channel_wwn\u0026quot;: [], \u0026quot;fips\u0026quot;: false, \u0026quot;form_factor\u0026quot;: \u0026quot;Other\u0026quot;, \u0026quot;fqdn\u0026quot;: \u0026quot;ip-10-32-1-186.ap-east-1.compute.internal\u0026quot;, \u0026quot;gather_subset\u0026quot;: [ \u0026quot;all\u0026quot; ], \u0026quot;hostname\u0026quot;: \u0026quot;ip-10-32-1-186\u0026quot;, \u0026quot;hostnqn\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;interfaces\u0026quot;: [ \u0026quot;lo\u0026quot;, \u0026quot;eth0\u0026quot; ], \u0026quot;is_chroot\u0026quot;: true, \u0026quot;iscsi_iqn\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;kernel\u0026quot;: \u0026quot;5.10.135-122.509.amzn2.x86_64\u0026quot;, \u0026quot;kernel_version\u0026quot;: \u0026quot;#1 SMP Thu Aug 11 22:41:16 UTC 2022\u0026quot;, \u0026quot;lo\u0026quot;: { \u0026quot;active\u0026quot;: true, \u0026quot;device\u0026quot;: \u0026quot;lo\u0026quot;, \u0026quot;features\u0026quot;: { \u0026quot;esp_hw_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;esp_tx_csum_hw_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;fcoe_mtu\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;generic_receive_offload\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;generic_segmentation_offload\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;highdma\u0026quot;: \u0026quot;on [fixed]\u0026quot;, \u0026quot;hw_tc_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;l2_fwd_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;large_receive_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;loopback\u0026quot;: \u0026quot;on [fixed]\u0026quot;, \u0026quot;macsec_hw_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;netns_local\u0026quot;: \u0026quot;on [fixed]\u0026quot;, \u0026quot;ntuple_filters\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;receive_hashing\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_all\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_checksumming\u0026quot;: \u0026quot;on [fixed]\u0026quot;, \u0026quot;rx_fcs\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_gro_hw\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_gro_list\u0026quot;: \u0026quot;off\u0026quot;, \u0026quot;rx_udp_tunnel_port_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_vlan_filter\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_vlan_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_vlan_stag_filter\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;rx_vlan_stag_hw_parse\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;scatter_gather\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;tcp_segmentation_offload\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;tls_hw_record\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tls_hw_rx_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tls_hw_tx_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_checksum_fcoe_crc\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_checksum_ip_generic\u0026quot;: \u0026quot;on [fixed]\u0026quot;, \u0026quot;tx_checksum_ipv4\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_checksum_ipv6\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_checksum_sctp\u0026quot;: \u0026quot;on [fixed]\u0026quot;, \u0026quot;tx_checksumming\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;tx_esp_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_fcoe_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_gre_csum_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_gre_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_gso_list\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_gso_partial\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_gso_robust\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_ipxip4_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_ipxip6_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_lockless\u0026quot;: \u0026quot;on [fixed]\u0026quot;, \u0026quot;tx_nocache_copy\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_scatter_gather\u0026quot;: \u0026quot;on [fixed]\u0026quot;, \u0026quot;tx_scatter_gather_fraglist\u0026quot;: \u0026quot;on [fixed]\u0026quot;, \u0026quot;tx_sctp_segmentation\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;tx_tcp6_segmentation\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;tx_tcp_ecn_segmentation\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;tx_tcp_mangleid_segmentation\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;tx_tcp_segmentation\u0026quot;: \u0026quot;on\u0026quot;, \u0026quot;tx_tunnel_remcsum_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_udp_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_udp_tnl_csum_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_udp_tnl_segmentation\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_vlan_offload\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;tx_vlan_stag_hw_insert\u0026quot;: \u0026quot;off [fixed]\u0026quot;, \u0026quot;udp_fragmentation_offload\u0026quot;: \u0026quot;off\u0026quot;, \u0026quot;vlan_challenged\u0026quot;: \u0026quot;on [fixed]\u0026quot; }, \u0026quot;hw_timestamp_filters\u0026quot;: [], \u0026quot;ipv4\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;127.0.0.1\u0026quot;, \u0026quot;broadcast\u0026quot;: \u0026quot;host\u0026quot;, \u0026quot;netmask\u0026quot;: \u0026quot;255.0.0.0\u0026quot;, \u0026quot;network\u0026quot;: \u0026quot;127.0.0.0\u0026quot; }, \u0026quot;ipv6\u0026quot;: [ { \u0026quot;address\u0026quot;: \u0026quot;::1\u0026quot;, \u0026quot;prefix\u0026quot;: \u0026quot;128\u0026quot;, \u0026quot;scope\u0026quot;: \u0026quot;host\u0026quot; } ], \u0026quot;mtu\u0026quot;: 65536, \u0026quot;promisc\u0026quot;: false, \u0026quot;timestamping\u0026quot;: [ \u0026quot;tx_software\u0026quot;, \u0026quot;rx_software\u0026quot;, \u0026quot;software\u0026quot; ], \u0026quot;type\u0026quot;: \u0026quot;loopback\u0026quot; }, \u0026quot;lsb\u0026quot;: {}, \u0026quot;machine\u0026quot;: \u0026quot;x86_64\u0026quot;, \u0026quot;machine_id\u0026quot;: \u0026quot;ec2a0c93cafdf59f762c6748bad6ea6e\u0026quot;, \u0026quot;memfree_mb\u0026quot;: 578, \u0026quot;memory_mb\u0026quot;: { \u0026quot;nocache\u0026quot;: { \u0026quot;free\u0026quot;: 794, \u0026quot;used\u0026quot;: 146 }, \u0026quot;real\u0026quot;: { \u0026quot;free\u0026quot;: 578, \u0026quot;total\u0026quot;: 940, \u0026quot;used\u0026quot;: 362 }, \u0026quot;swap\u0026quot;: { \u0026quot;cached\u0026quot;: 0, \u0026quot;free\u0026quot;: 0, \u0026quot;total\u0026quot;: 0, \u0026quot;used\u0026quot;: 0 } }, \u0026quot;memtotal_mb\u0026quot;: 940, \u0026quot;module_setup\u0026quot;: true, \u0026quot;mounts\u0026quot;: [ { \u0026quot;block_available\u0026quot;: 1668655, \u0026quot;block_size\u0026quot;: 4096, \u0026quot;block_total\u0026quot;: 2094075, \u0026quot;block_used\u0026quot;: 425420, \u0026quot;device\u0026quot;: \u0026quot;/dev/nvme0n1p1\u0026quot;, \u0026quot;fstype\u0026quot;: \u0026quot;xfs\u0026quot;, \u0026quot;inode_available\u0026quot;: 4145004, \u0026quot;inode_total\u0026quot;: 4193216, \u0026quot;inode_used\u0026quot;: 48212, \u0026quot;mount\u0026quot;: \u0026quot;/\u0026quot;, \u0026quot;options\u0026quot;: \u0026quot;rw,noatime,attr2,inode64,logbufs=8,logbsize=32k,noquota\u0026quot;, \u0026quot;size_available\u0026quot;: 6834810880, \u0026quot;size_total\u0026quot;: 8577331200, \u0026quot;uuid\u0026quot;: \u0026quot;2318d4b7-b8cd-4579-ab46-47af13e15000\u0026quot; } ], \u0026quot;nodename\u0026quot;: \u0026quot;ip-10-32-1-186.ap-east-1.compute.internal\u0026quot;, \u0026quot;os_family\u0026quot;: \u0026quot;RedHat\u0026quot;, \u0026quot;pkg_mgr\u0026quot;: \u0026quot;yum\u0026quot;, \u0026quot;proc_cmdline\u0026quot;: { \u0026quot;BOOT_IMAGE\u0026quot;: \u0026quot;/boot/vmlinuz-5.10.135-122.509.amzn2.x86_64\u0026quot;, \u0026quot;biosdevname\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;console\u0026quot;: [ \u0026quot;tty0\u0026quot;, \u0026quot;ttyS0,115200n8\u0026quot; ], \u0026quot;net.ifnames\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;nvme_core.io_timeout\u0026quot;: \u0026quot;4294967295\u0026quot;, \u0026quot;rd.emergency\u0026quot;: \u0026quot;poweroff\u0026quot;, \u0026quot;rd.shell\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;ro\u0026quot;: true, \u0026quot;root\u0026quot;: \u0026quot;UUID=2318d4b7-b8cd-4579-ab46-47af13e15000\u0026quot; }, \u0026quot;processor\u0026quot;: [ \u0026quot;0\u0026quot;, \u0026quot;GenuineIntel\u0026quot;, \u0026quot;Intel(R) Xeon(R) Platinum 8259CL CPU @ 2.50GHz\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;GenuineIntel\u0026quot;, \u0026quot;Intel(R) Xeon(R) Platinum 8259CL CPU @ 2.50GHz\u0026quot; ], \u0026quot;processor_cores\u0026quot;: 1, \u0026quot;processor_count\u0026quot;: 1, \u0026quot;processor_threads_per_core\u0026quot;: 2, \u0026quot;processor_vcpus\u0026quot;: 2, \u0026quot;product_name\u0026quot;: \u0026quot;t3.micro\u0026quot;, \u0026quot;product_serial\u0026quot;: \u0026quot;NA\u0026quot;, \u0026quot;product_uuid\u0026quot;: \u0026quot;NA\u0026quot;, \u0026quot;product_version\u0026quot;: \u0026quot;NA\u0026quot;, \u0026quot;python\u0026quot;: { \u0026quot;executable\u0026quot;: \u0026quot;/usr/bin/python\u0026quot;, \u0026quot;has_sslcontext\u0026quot;: true, \u0026quot;type\u0026quot;: \u0026quot;CPython\u0026quot;, \u0026quot;version\u0026quot;: { \u0026quot;major\u0026quot;: 2, \u0026quot;micro\u0026quot;: 18, \u0026quot;minor\u0026quot;: 7, \u0026quot;releaselevel\u0026quot;: \u0026quot;final\u0026quot;, \u0026quot;serial\u0026quot;: 0 }, \u0026quot;version_info\u0026quot;: [ 2, 7, 18, \u0026quot;final\u0026quot;, 0 ] }, \u0026quot;python_version\u0026quot;: \u0026quot;2.7.18\u0026quot;, \u0026quot;real_group_id\u0026quot;: 1000, \u0026quot;real_user_id\u0026quot;: 1000, \u0026quot;selinux\u0026quot;: { \u0026quot;status\u0026quot;: \u0026quot;Missing selinux Python library\u0026quot; }, \u0026quot;selinux_python_present\u0026quot;: false, \u0026quot;service_mgr\u0026quot;: \u0026quot;systemd\u0026quot;, \u0026quot;ssh_host_key_ecdsa_public\u0026quot;: \u0026quot;AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBMQHztuwL47pwpF7HDjl61XRcALUQSBkQB+xJhMA5m7+z0CZxtyY1W93Jz7YcFEbYuGNzbnb51i67iTOG+0+oOs=\u0026quot;, \u0026quot;ssh_host_key_ed25519_public\u0026quot;: \u0026quot;AAAAC3NzaC1lZDI1NTE5AAAAIGctEOyP5SdD+z5uIV/UPvpn8e2cbgw0zNjFegk8haAf\u0026quot;, \u0026quot;ssh_host_key_rsa_public\u0026quot;: \u0026quot;AAAAB3NzaC1yc2EAAAADAQABAAABAQC+oJTDejKkf4IX/+vwayNQ3OSD+HwRnDIQT73cbZsDpMo0Hnl2ORwVxwCibih2nTc9VrF839ItfP8NBIQHADFz6EqAMJQ+qyMMy5Vlm+w1AajSNk7SxZEfGqo4w8bbXnLgmWmCk5Q5lhzIXvwsECnLs98Ld3tGSKqHgCJLJ1qec/UNa4NGoyey+0wwAvUfjAInjUWE20U5ZHAq7Ji8fxo6Ws6hZ0tgy/XZ5EkqV0jVwqzsCl6eQH11q/Dm9N+YetNr5oJrIH/R5syiSc6ChgFjXBhjoonf5YzUuPoPdXqR6y8snuuZKGIadG3a72G0pZbpx5u97bQZODwcC267NG+v\u0026quot;, \u0026quot;swapfree_mb\u0026quot;: 0, \u0026quot;swaptotal_mb\u0026quot;: 0, \u0026quot;system\u0026quot;: \u0026quot;Linux\u0026quot;, \u0026quot;system_capabilities\u0026quot;: [ \u0026quot;\u0026quot; ], \u0026quot;system_capabilities_enforced\u0026quot;: \u0026quot;True\u0026quot;, \u0026quot;system_vendor\u0026quot;: \u0026quot;Amazon EC2\u0026quot;, \u0026quot;uptime_seconds\u0026quot;: 11454, \u0026quot;user_dir\u0026quot;: \u0026quot;/home/ec2-user\u0026quot;, \u0026quot;user_gecos\u0026quot;: \u0026quot;EC2 Default User\u0026quot;, \u0026quot;user_gid\u0026quot;: 1000, \u0026quot;user_id\u0026quot;: \u0026quot;ec2-user\u0026quot;, \u0026quot;user_shell\u0026quot;: \u0026quot;/bin/bash\u0026quot;, \u0026quot;user_uid\u0026quot;: 1000, \u0026quot;userspace_architecture\u0026quot;: \u0026quot;x86_64\u0026quot;, \u0026quot;userspace_bits\u0026quot;: \u0026quot;64\u0026quot;, \u0026quot;virtualization_role\u0026quot;: \u0026quot;guest\u0026quot;, \u0026quot;virtualization_type\u0026quot;: \u0026quot;kvm\u0026quot; } } PLAY RECAP ********************************************************************* 16.163.95.41 : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 Chúng ta có thể lấy được python_version với việc chúng ta sửa lại file Playbook như sau:\n--- - hosts: webserver gather_facts: true tasks: - name: \u0026quot;Show ansiblr Facts\u0026quot; debug: var: ansible_facts['python_version'] và đây là kết quả:\nbài viết lần này của mình tạm dừng ở đây, hy vọng khi bạn làm theo những bước mình đã viết, bạn có thể hiểu được phần nào về biến trong Ansible, học phải đi đôi với hành đúng k nào!!!!\n","description":"","id":17,"section":"posts","tags":["Devops","Aws"],"title":"[Dành cho Beginner] Phần 2: Biến trong Ansible","uri":"https://hungpt.info/en/posts/bien_trong_ansible/"},{"content":"AWS Amplify là gì? AWS Amplify là một tập hợp các công cụ và tính năng được tạo ra có chủ đích, giúp nhà phát triển web và di động frontend xây dựng các ứng dụng fullstack một cách nhanh chóng và dễ dàng trên AWS với khả năng tận dụng linh hoạt các dịch vụ AWS phong phú khi các trường hợp sử dụng của bạn tiến triển.\n1. Chuẩn bị Đăng nhập vào github.com\nMáy Ubuntu EC2, security group mở port 443(https)\nGithub Token, để đấy code lên github\nKiểm tra chi phí sử dụng dịch vụ\nAplify : https://aws.amazon.com.amplify/pricing\n2. Tạo repository trên giao diện github.com  Nhấn vào dấu cộng góc trên cùng bên phải (New repository) Điền tên : simpleCICD Chọn private, Create repository  3. Đẩy code từ máy ảo EC2  Tạo thư mục mới : mkdir simpleCICD cd simpleCICD Tạo file index.html như hình bên dưới: touch index.html  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt; \u0026lt;link rel=\u0026quot;icon\u0026quot; href=\u0026quot;%PUBLIC_URL%/favicon.ico\u0026quot; /\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1\u0026quot; /\u0026gt; \u0026lt;meta name=\u0026quot;theme-color\u0026quot; content=\u0026quot;#000000\u0026quot; /\u0026gt; \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;Web site created using create-react-app\u0026quot; /\u0026gt; \u0026lt;link rel=\u0026quot;apple-touch-icon\u0026quot; href=\u0026quot;%PUBLIC_URL%/logo192.png\u0026quot; /\u0026gt; \u0026lt;link rel=\u0026quot;manifest\u0026quot; href=\u0026quot;%PUBLIC_URL%/manifest.json\u0026quot; /\u0026gt; \u0026lt;title\u0026gt;React App\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;noscript\u0026gt;You need to enable JavaScript to run this app.\u0026lt;/noscript\u0026gt; \u0026lt;div\u0026gt; test simplify CICD simpleCICD \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Khởi tạo một git repo mới trong thư mục simpleCICD git init git remote add origin https://github.com/zyn1030z/simpleCICD.git git add . git commit -m “my first commit” git push –set-upstream origin master(push code lên nhánh master, đăng nhập user và token)\n  4. Khởi tạo AWS Amplify Trên giao diện AWS Console\n Search aws amplify, chọn Amplify Hosting, chọn tiếp Github, Continue(Đăng nhập sẵn Github nên tích hợp được\nluôn)\n Nhấn vào Authorize aws-amplify-console\n Chọn tiếp Respository simpleCICD và nhánh Main, ấn Next\n Chọn tích vào ô: Allow AWS Amplify to automatically deploy all files hosted in your project root directory và\nấn Next chọn tiếp Save and Deploy\n Ta thấy các quy trình tự động (chờ khoản 1 đến 3 phút), đến khi hoàn tất\n Kết quả hệ thống tạo ra 1 đường link (https://main...amplifyapp.com), bên phía trái dưới biểu tượng mũi tên.\nNhấn vào đấy để thấy trang web của chúng ta đã được deploy. Nếu ấn sớm sẽ nhận được thông báo, khi nào xong trang web\nsẽ hiển thị ở đây\n  5. Tạo nhánh cho coder Quay lại máy EC2, tạo thêm nhánh git branch cho Coder, sau đó push code lên github:\n Tạo thêm 1 branch nữa(dev) : git btanch dev Kiểm ta lại : git branch Tạo thêm nhánh mới (Staging) : git branch Staging Kiểm tra lại : git branch(Staging đã được tạo thêm tổng cộng 3 nhánh) Chuyển sang branch dev : git checkout dev Sửa 1 số dòng ở đoạn code trong file index.html chúng ta đã tạo git add .* Tạo ghi chú : git commit -m ‘mofify dev branch’ push code lên github : git púh –set-upstream origin dev\n Tương tự chúng ta cũng sẽ làm với nhánh Staging\n  6. Connect branch trên AWS Trên giao diện AWS: phần aws amplify, chọn Connect branch để kết nối thêm các Repository branch và deploy\ncác branch riêng:\nNhấn vào Connect branch và làm giống với nhánh main nhưng phần branch thì lần lượt chọn dev và staging\nNhư vậy chúng ta đã triển khai được code tự động từ Github lên Host trên aws để chạy trang web theo\ncác Branch khác nhau: dev, main,staging\n","description":"","id":19,"section":"posts","tags":["Devops","AWS"],"title":"[Dành cho Beginner] AWS Amplify host CI/CD","uri":"https://hungpt.info/en/posts/aws_amplify_host_cicd/"},{"content":"Trong một môi trường với nhiều server thì ta sẽ có vô vàn thứ phải lo. Từ setup crontab, update các gói phần mềm mới, deploy ứng dụng mới, chỉnh sửa file cấu hình…. Những công việc này tuy không khó, nhưng rất mất thời gian của những người quản trị (SysAdmin/SysEngineer/DevOps).\nVậy có cách nào để tự động hóa những thao tác nhàm chán, lặp đi lặp lại này không?\n“Cùng một việc mà làm quá 2 lần thì có gì đó không ổn rồi”\nTừ một giảng viên cũ từng dạy mình\nCâu trả lời chính là ứng dụng những tool automation để quản trị hệ thống. Hiện nay có rất nhiều tool như vậy trên thị trường cụ thể như: Chef, Puppet, CFEngine, StackStorm, Ansible, SaltStack… Trong bài này, mình sẽ giới thiệu đến các bạn một công cụ rất mạnh mẽ trong việc quản trị hệ thống, đó chính là Ansible.\n1. Giới thiệu Ansible Như đã nói ở trên, Ansible là một công cụ dùng để tự động hóa việc cấu hình trên nhiều server. So với các công cụ khác với tính năng tương đương thì Ansible dễ học và dễ tiếp cận hơn rất nhiều. Cộng đồng người dùng cũng nhiều hơn so với\ncác công cụ khác.\nSo sánh một vài thông số về Ansible, SaltStack, Chef, Puppet trên GitHub (11/2018)\nCó thể thấy Ansible là công cụ tự động hóa phổ biến nhất trên GitHub với số sao được người dùng bình chọn cho project này là 33,500 sao. Ansible cũng là tool dễ tiếp cận và làm quen do được build bằng Python và sử dụng file cấu hình theo dạng YAML (YAML Ain’t Markup Language) dễ đọc và dễ hiểu.\n2. Kiến trúc Ansible sử dụng kiến trúc agentless để giao tiếp với các máy khác mà không cần agent. Cơ bản nhất là giao tiếp thông qua giao thức SSH trên Linux, WinRM trên Windows hoặc giao tiếp qua chính API của thiết bị đó cung cấp.\nAnsible có thể giao tiếp với rất nhiều platform, OS và loại thiết bị khác nhau. Từ Ubuntu, CentOS, VMware, Windows cho tới AWS, Azure, các thiết bị mạng Cisco và Juniper….vân vân và mây mây….(hoàn toàn không cần agent khi giao tiếp).\nChính cách thiết kế này làm tăng tính tiện dụng của Ansible do không cần phải setup bảo trì agent trên nhiều host. Có thể coi đây là một thế mạnh của Ansible so với các công cụ có cùng chức năng như Chef, Puppet, SaltStack (Salt thì hỗ trợ cả 2 mode là agent và agentless, có thời gian thì mình sẽ viết 1 bài về Salt).\n3. Ứng dụng Ansible có rất nhiều ứng dụng trong triển khai phần mềm và quản trị hệ thống.\n Provisioning: Khởi tạo VM, container hàng loạt trong môi trường cloud dựa trên API (OpenStack, AWS, Google Cloud, Azure…) Configuration Management: Quản lý cấu hình tập trung các dịch vụ tập trung, không cần phải tốn công chỉnh sửa cấu hình trên từng server. Application Deployment: Deploy ứng dụng hàng loạt, quản lý hiệu quả vòng đời của ứng dụng từ giai đoạn dev cho tới production. Security \u0026amp; Compliance: Quản lý các chính sách về an toàn thông tinmột cách đồng bộ trên nhiều môi trường và sản phẩm khác nhau (deploy policy, cấu hình firewall hàng loạt trên nhiều server…).  4. Cài đặt Ansiable Bước 1: Tạo EC2 Trên AWS tạo 03 Launch template cho EC2 sử dụng AMI: Amazon Linux 2, Ubuntu 20, RedHat. Chú ý Advanced network configuration chọn Auto IP Public: Enable\nTiến hành ssh vào EC2 ubuntu\nTạo 1 thư mục, trong thư mục đó chúng ta sẽ tạo 1 file host để lưu ip của 2 máy EC2 còn lại như sau\nSau đó chúng ta chạy lệnh\nansible -i hosts webserver -m ping Sẽ có 1 lỗi như sau bởi chúng ta chưa có private key để ssh vào 2 máy EC2 còn lại\nChúng ta sẽ phải tải file lên máy EC2 ubuntu này với lệnh sau:\n1  scp -i web1.pem web1.pem ubuntu@16.162.23.244:/home/ubuntu/.ssh   Bạn lần lượt gõ 2 lệnh này để convert file pem thành private key và tạo public key để ssh tới 2 máy EC2 còn lại\nNếu vẫn chưa được bạn sẽ phải thêm ansible_ssh_user=ec2-user\nChạy lệnh sau chúng ta sẽ được kết quả\nTiếp theo chúng ta sẽ thao tác với playbook trong Ansible, chúng ta sẽ viết 1 playbook đơn giản như sau:\n1 2 3  - hosts: webserver tasks: - ping:   Sau đó chúng ta chạy lệnh sau với playbook.yml là file chúng ta sẽ viết code ở trên\n1  ansible-playbook -i hosts playbook.yaml   Kết quả chúng ta sẽ được như sau:\nBài viết lần này của mình dừng lại ở đây, ở phần sau chúng ta sẽ cùng tìm hiểu sâu hơn về Ansible nhé!\n","description":"","id":20,"section":"posts","tags":["Devops","Ansible","AWS"],"title":"[Dành cho Beginner] Phần 1: Ansible Là Gì? Hướng Dẫn Cài Đặt Ansible? Viết 1 Playbook đơn giản","uri":"https://hungpt.info/en/posts/ansible_cat_dat/"},{"content":"Để quản lý State trong React Function Component, chúng ta dùng Hook useState().\nHàm useState trả về 1 mảng 2 phần tử, phần tử đầu tiên là để khởi tạo state, phần tử thứ 2 là hàm để cập nhật state. Tham số truyền vào hàm useState là giá trị khởi tạo của state. Ví dụ:\nKhai báo State Phải khai báo useState ở top level của một Function Component (hoặc một custom Hook), không khai báo ở trong một scope nào khác như vòng lặp, điều kiện, hay function con. Ví dụ khai báo state như sau là sai:\n1 2 3 4 5 6 7  export default function App() { function handleClick() { const [count, setCount] = useState(0); // Phải khai báo state ở top-level của Function component  } ... }   Có thể khai báo nhiều biến state khác nhau. Ví dụ:\n1 2 3 4 5 6 7 8 9 10 11  export default function App() { const [count1, setCount1] = useState(0); const [count2, setCount2] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count1}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{count2}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }   Cập nhật State Mỗi khi state được cập nhật thì Component sẽ re-render (function được chạy lại và giao diện được cập nhật lại theo state). Cần chú ý là không được thay đổi trực tiếp biến state (immutable) mà phải cập nhật thông qua hàm cập nhật state.\nVí dụ như sau là sai:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  export default function App() { const [count, setCount] = useState(0); function handleClick() { count++; // Không được thay đổi trực tiếp state như này  } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Increase count\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }   Ví dụ như này là đúng:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  export default function App() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); // Thay đổi state bằng cách gọi hàm setCount  } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Increase count\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }   Chú ý với các state là array hoặc object thì nên copy giá trị ra 1 biến mới để không làm thay đổi giá trị cũ (pass by reference). Ví dụ:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  export default function App() { const [arr, setArr] = useState([1, 2, 3]); // Cách sai  function addItemToArray1(item) { arr.push(item); // Hàm push làm thay đổi giá trị của state arr  setArr(arr); // React không phát hiện có sự thay đổi state nào nên không cập nhật lại giao diện  } // Cách đúng  function addItemToArray2(item) { setArr([...arr, item]); // Không thay đổi trực tiếp state arr mà tạo ra 1 mảng mới bằng spread syntax  } }   Cập nhật state sử dụng callback function Thay vì cập nhật state bằng cách truyền vào giá trị mới, thì chúng ta có thể cập nhật state bằng cách truyền vào một hàm callback (có tham số là giá trị cũ) và trả về kết quả là giá trị mới. Ví dụ:\n1  setCount((prevCount) =\u0026gt; prevCount + 1);   Dùng cách này thì khi cập nhật state sẽ đảm bảo giá trị mới phụ thuộc vào giá trị cũ chứ không phụ thuộc vào giá trị của state ở thời điểm hiện tại. Tham khảo thêm https://reactjs.org/docs/hooks-reference.html#usestate.\nVí dụ với ứng dụng đếm số lượt bấm nút, nếu sửa lại hàm tăng số lượt bấm thành tăng số lượt bấm sau 1 khoảng thời gian (ví dụ 3 giây).\nNếu cập nhật state bằng cách sau thì khi người dùng bấm nút nhiều lần trong khoảng thời gian 3 giây, thì sau 3 giây giá trị của state cũng chỉ tăng lên 1 (lấy giá trị của state ở thời điểm hiện tại cộng thêm 1).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  export default function App() { const [count, setCount] = useState(0); function handleClick() { setTimeout(() =\u0026gt; { setCount(count + 1); // Thay đổi state dựa theo giá trị của state hiện tại  }, 3000); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Increase count after 3 seconds\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }   Nếu cập nhật state bằng cách truyền vào một hàm thì trong 3 giây delay, người dùng bấm nút bao nhiêu lần thì giá trị của state sẽ tăng lên bấy nhiêu.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  export default function App() { const [count, setCount] = useState(0); function handleClick() { setTimeout(() =\u0026gt; { setCount((prevCount) =\u0026gt; prevCount + 1); // Thay đổi state dựa theo giá trị của state trước đó  }, 3000); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Increase count after 3 seconds\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }   Như vậy tùy từng trường hợp mà chúng ta sẽ lựa chọn cách sử dụng sao cho hợp lý.\n","description":"","id":22,"section":"posts","tags":["Reactjs","Javascript"],"title":"Sử dụng useState() Hook trong React như nào cho đúng?","uri":"https://hungpt.info/en/posts/su-dung-usestate-hook-trong-react-nhu-nao-cho-dung/"},{"content":"Xin chào mọi người. Hôm nay chúng ta sẽ cùng tìm hiểu cách để có thể triển khai 1 ứng dụng NodeJS trên EC2 và thông tin dữ liệu được\nlưu ở S3 trên AWS nhé!\nMô hình triển khai Mình sẽ nói qua chút về mô hình triển khai của bài Lab này, yêu cầu của bài lab bao gồm:\n Chuẩn bị EC2 đã được cấu hình IAM Rule truy cập S3 Cài đặt NodeJS lên EC2 Lấy code NodeJS truy cập S3 và hiển thị nội dung(danh sách file, ảnh) trong S3 lên web\nChúng ta sẽ đến bài lab ngay bây giờ 😄  1. Chuẩn bị EC2 đã được cấu hình IAM Rule truy cập S3 Trước hết mình đã tạo 1 VPC, với subnet public và subnet private ở bài trước, bạn có thể đọc lại bài VPC trong AWS của mình\nBước 1: Tạo EC2, S3 Bucket với giao diện AWS Console Chúng ta lần lượt tạo EC2 và S3 Bucket như sau:\nchú ý ở bước tạo Network setting chúng ta sẽ chọn VPC public mà chúng ta tạo ở bài trước\nCác bước khác bạn làm tương tự như bài hướng dẫn về EC2\nTiếp theo mình sẽ tạo 1 S3 Bucket, nếu bạn chưa biết S3 Bucket là gì thì S3 Bucket là dịch vụ đám mây lưu trữ do đó bạn có thể tải lên các tệp, các tài liệu,\ncác dữ liệu tải về của người dùng hoặc các bản sao lưu.\nĐể hiểu về Amazon S3, bạn cần nắm 1 số khái niệm cơ bản:\n Amazon S3 lưu trữ dữ liệu như các object trong các bucket. Một object gồm 1 file và metadata mô tả cho file (tùy chọn). Để lưu 1 object trong Amazon S3, bạn tải file lên 1 bucket. Khi đã tải file, bạn có thể gán quyền cho đối tượng cũng như bổ sung metadata. Bucket là các thùng chứa cho các object. Bạn có thể tạo 1 hay nhiều bucket. Với mỗi bucket, bạn có thể điều khiển việc truy xuất đến nó (ai có thể tạo, xóa và xem các object trong bucket), xem nhật ký truy xuất đến bucket và đến các object bên trong, cũng như chọn region mà Amazon S3 sẽ lưu bucket và nội dung trong nó. Chú ý là mỗi một tài khoản chỉ tạo được tối đa là 100 buckets, và Bucket có tên là duy nhất\nMình sẽ tạo 1 S3 Bucket như sau:\nBạn cần bỏ tích chọn mục này\n  Bước 2: Tạo IAM Role Tạo 1 rule cho phép EC2 truy cập S3 như sau\nBước 3: Chỉnh sửa Bucket Policy Bước 4: Kiểm tra EC2 truy cập S3 mà không cần lưu trữ use/key/pass 2. Cài đặt NodeJS lên EC2 3. Lấy code NodeJS truy cập S3 và hiển thị nội dung(danh sách file, ảnh) trong S3 lên web","description":"","id":23,"section":"posts","tags":["Devops","AWS","CI/CD"],"title":"[Dành cho Beginner] Hướng dẫn triển khai ứng dụng NodeJS cho AWS trên EC2 và S3","uri":"https://hungpt.info/en/posts/deploy_nodejd_ec2_s3_in_aws/"},{"content":"Nếu bạn đọc soure code của core Odoo, đôi khi bạn sẽ tìm thấy safe_eval. Bạn đã bao giờ tự hỏi, safe_eval là gì chưa? Và nó sử dụng để làm gì?\nNếu bạn đọc mã nguồn của Odoo, bạn sẽ thấy rằng, safe_eval thực ra chỉ là một hàm/module được viết bằng python.\nNếu bạn không biết, module eval được sử dụng để xử lý các biểu thức với kiểu dữ liệu là chuỗi, để chúng có thể được đọc dưới dạng\nphép toán hoặc thậm chí là 1 đoạn mã python hợp lệ. Giả sử chúng ta có 1 biến với kiểu dữ liệu là chuỗi như bên dưới đây:\nmy_string = '100 + 5' Bằng cách sử dụng eval chúng ta có thể biến chuỗi trên thành 1 phép toán hợp lệ như sau:\nmy_string = '100 + 5' value = eval(my_string) print(value) Như bạn thấy kết quả của phép toán là 105 là kết quả của phép tính 100 + 5.\nModule eval cũng có thể được sử dụng ở những trường hợp biểu thức được gán vào các biến như sau:\na = 100 b = 5 my_string = 'a + b' value = eval(my_string) Hoặc chúng ta cũng có thể biết như sau:\nmy_string = 'a + b' value = eval(my_string, {'a': 100, 'b': 5}) Như mình đã viết trước đó, module safe_eval thực sự chỉ là thư viện tích hợp eval của python và sửa đổi một chút.\nDo đó, đoan mã trên cũng có thể được viết bằng module safe_eval như sau:\nfrom odoo.tools.safe_eval import safe_eval my_string = 'a + b' value = safe_eval(my_string, {'a': 100, 'b': 5}) Vậy sự khác biệt khi chúng ta sử dụng eval và safe_eval ở đây là gì?\nsafe_eval sẽ đưa vào danh sách cấm 1 số biểu thức, nhưng với eval thì với những biểu thức như vậy thì không vấn đề gì?\nHàm đầu tiên mà safe_eval đưa vào danh sách cấm là import. Mình có 1 ví dụ ở dưới đây:\nmy_string = \u0026quot;__import__('odoo').tools.float_round(a/b,pricision)\u0026quot; Nhưng đối với eval biểu thức trên lại không gây ra lỗi như sau:\neval_value = eval(my_string, {'a': 15, 'b': 2, 'pricision': 0}) Nhưng nếu chuyển biểu thức này sang bên safe_eval thì lại gây ra lỗi:\nsafe_eval_value = safe_eval(my_string, {'a': 15, 'b': 2, 'pricision': 0} Sẽ có lỗi như hình dưới đây\nChúng ta cũng có thể thay đổi chế độ safe_eval, theo mặc định khi chúng ta gọi safe_eval, odoo sẽ thực thi module eval của python.\nNhưng chúng ta cũng có thể thay thế module eval bằng 1 module khác, ví dụ như đoạn code dưới đây:\nmy_string = \u0026quot;c = a + b\u0026quot; my_value = {'c': 1} print('my_value==before==', my_value) # my_value==before== {'c': 1} safe_eval(my_string, {'a': 4, 'b': 7}, my_value, mode=\u0026quot;exec\u0026quot;, nocopy=True) print('my_value==after==', my_value) # my_value==after== {'c': 11} Trong trường hợp bạn không rõ, nếu chúng ta truyền biểu thức c = a + b vào module eval, nó sẽ gây ra lỗi bởi vì c = a + b\nkhông phải là 1 biểu thức. Nhưng nếu bản truyền mode=“exec thì đoạn code trên sẽ không gây ra lỗi. Nhưng với mode=“exec”\nthì sẽ không trả về giá trị, do đó chúng ta phải truyền vào đối số thứ 3 là biến my_value để lưu trữ giá trị tính toán.\nLưu ý chút là nếu như bạn gọi module safe_eval ở chế độ thực thi, chúng ta phải đặt giá trị của đối số no_copy = True, nếu không\ngiá trị my_value sẽ không thay đổi.\nVậy, trong Odoo safe_eval được sử dụng chính để làm gì?.\nĐầu tiên safe_eval được sử dụng để đánh giá, validate 1 miền chuỗi. Ví dụ trong module pos_loyalty trong odoo 14 enterprise. Hoặc trong\nmodule mình có viết ở đây để giới hạn động quyền truy cập nút in.\nTrong module này mình có viết 1 field là condition với kiểu dữ liệu là Char, trong view mình cho hiển thị lên trường này với\nwidget là domain mặc định của odoo. Widget này cho mọi người viết domain một cách dễ dàng và domain người dùng nhập vào vẫn được lưu dưới dạng Char\nBởi vì tên miền được lưu dưới dạng Char trong cơ sở dữ liệu, nên tất nhiên chúng ta không thể chuyển tên miền trực tiếp đến phương thức tìm kiếm hoặc\nbất kỳ mật phương thức vào khác được. Vì vậy chúng ta phải thay đổi nó thành 1 domain hợp lệ là 1 List, chúng ta có thể sử dụng điều này bằng cách sử\ndụng safe_eval. Tuy nhiên đối với Odoo, cách convert từ string qua List cũng không nhất quán, như ở trong module coupon việc này\nsử dụng bởi module ast cũng là một module có sẵn trong python.\nMột trường hợp khác mà Odoo sử dụng safe_eval đó là việc tính toán báo cáo lãi lỗ và bảng cân đối kế toán trong Odoo enterprise. Bạn có thể\ntìm thấy nó theo Kế toán » Cấu hình »\u0026gt; Báo cáo tài chính » Lãi lỗ\nMình sẽ ví dụ thêm như sau:\nmy_string = 'S00006 + S00007' Chúng ta sẽ sử lý chuỗi này, lấy nó ra để tính toán cũng như tìm kiếm. Đầu tiên mình sẽ tạo ra 1 class được kế thừa từ lớp Dict\nclass DataSet(dict): def __init__(self, model, field_to_search, field_to_calculate): super().__init__() self.model = model self.field_to_search = field_to_search self.field_to_calculate = field_to_calculate def __getitem__(self, item): record = self.model.search([(self.field_to_search,'=',item)],limit=1) if record: return getattr(record, self.field_to_calculate) else: return 0 Sau đó khi chúng ta gọi safe_eval, chúng ta có thể sử dụng lớp Dataset làm đối số như đoạn code dưới đây\nmy_string = 'S00006 + S00007' value = safe_eval(my_string,DataSet(self.env['sale.order'],'name','amount_total'), nocopy=True) Khi safe_Eval cố gắng lấy giá trị biểu thức, safe_Eval sẽ kích hoạt phương thức get_item_. Đây là lý do chúng ta ghi đè phương thức để này để trả về giá trị động.\nNếu chúng ta sử dụng safe_eval cho các mục đích khác nhau, chẳng hạn như lấy giá trị tổng phụ của đơn hàng, như đoạn code dưới đây:\nmy_string = 'P00006 + P00007' value = safe_eval(my_string,DataSet(self.env['purchase.order'],'name','amount_untaxed'), nocopy=True) Đó là tất cả những gì mình viết về sale_eval, ngay bản thân tên của safe_eval đã chứng minh rằng safe_eval sẽ đưa một số biểu thức vào danh sách đen, mình\nhy vọng khi sử dụng , ứng dụng mình viết có thể an toàn hơn 😄. Bài viết còn nhiều thiếu sót, mong các bạn thông cảm nha.\n","description":"","id":24,"section":"posts","tags":["Odoo","Python"],"title":"Cách sử dụng safe_eval trong Odoo","uri":"https://hungpt.info/en/posts/safe_eval_in_odoo/"},{"content":"Xin chào mọi người. Hôm nay chúng ta sẽ cùng tìm hiểu về VPN trong AWS.\n","description":"","id":25,"section":"posts","tags":["Devops"],"title":"[Dành cho Beginner] VPN trong AWS","uri":"https://hungpt.info/en/posts/vpn_in_aws/"},{"content":"Xin chào mọi người. Hôm nay chúng ta sẽ cùng tìm hiểu về IAM (Identity and Access Management) trong AWS.\nChắc hẳn khi mới bắt đầu tìm hiểu về Amazon Web Services, IAM là một trong những khái niệm mà chúng ta tiếp xúc đầu tiên. Cùng bắt đầu thôi!\n1.IAM (Identity and Access Management) là gì? IAM (Identity and Access Management) tạm dịch là “Quản lý truy cập và nhận dạng” là một dịch vụ web giúp bạn kiểm soát\ntruy cập an toàn vào các tài nguyên AWS. Bạn sử dụng IAM để kiểm soát ai được xác thực (đăng nhập) và được ủy quyền (có quyền) để sử dụng tài nguyên.\nIAM cung cấp cho bạn một số tính năng sau:\n Chia sẻ quyền truy cập vào tài khoản AWS của bạn: Bạn có thể cấp cho người khác quyền quản trị và sử dụng tài nguyên trong tài khoản AWS của bạn mà không phải chia sẻ mật khẩu hoặc khóa truy cập. Cấp phép chi tiết: Bạn có thể cấp các quyền khác nhau cho những người khác nhau sử dụng các tài nguyên khác nhau. Truy cập an toàn vào tài nguyên AWS cho các ứng dụng chạy trên Amazon EC2 Bạn có thể cung cấp thông tin đăng nhập an toàn cho các ứng dụng chạy trên các phiên bản EC2 Xác thực đa yếu tố (MFA): Bạn có thể thêm xác thực hai yếu tố vào tài khoản của mình và cho từng người dùng để bảo mật hơn. Thông tin nhận dạng để đảm bảo: Nếu bạn sử dụng AWS CloudTrail, bạn sẽ nhận được các bản ghi nhật ký bao gồm thông tin về những người đã yêu cầu tài nguyên trong tài khoản của bạn. Thông tin đó dựa trên danh tính IAM. Sử dụng miễn phí: IAM được cung cấp miễn phí. Bạn chỉ phải trả phí cho việc sử dụng các dịch vụ của AWS trên tài khoản của bạn.  2. User, Group, Role, Policy IAM là khái niệm vô cùng quan trọng trong bảo mật của AWS. Hiểu về cách IAM hoạt động chính là hiểu về việc xác thực, cấp phép và uỷ quyền trong AWS.\nKhi đăng kí và truy cập tài khoản, đầu tiên, bạn sẽ đăng nhập với tư cách là người dùng gốc (Tài khoản root)\nTuy nhiên, khi bạn sử dụng thông tin đăng nhập tài khoản root, bạn có quyền truy cập đầy đủ, không hạn chế vào tất cả các tài nguyên trong tài khoản AWS của bạn, bao gồm quyền truy cập vào thông tin thanh toán và khả năng thay đổi mật khẩu của bạn. Mức truy cập này là cần thiết khi bạn lần đầu tiên thiết lập tài khoản của mình. Tuy nhiên, vì lý do bảo mật cho cả bản thân và những người khác cần làm việc với tài nguyên AWS của bạn, AWS khuyên bạn không nên sử dụng thông tin xác thực người dùng root để truy cập và sử dụng AWS, thay vào đó là việc sử dụng tài khoản IAM User. Đó cũng là lý do vì sao chúng ta cần hiểu rõ các khái niệm tiếp sau đây về User, Group, Role, Policy.\nChúng ta hãy nhìn vào sơ đồ dưới đây để hiểu từng khái niệm.\nUser Là tài khoản với sự uỷ nhiệm (Credentials) vĩnh viễn, được tạo và cấp quyền bời tài khoản root. Chúng ta đăng nhập vào User bằng. 1 User bao gồm user name, console password, accesskey,…\nGroup Là 1 nhóm bao gồm nhiều user. Đồng thời, 1 user cũng có thể thuộc về nhiều group.\nRole Là 1 tập các quyền mà bạn có thể sử dụng để truy cập các tài nguyên AWS mà bạn cần. Tuy nhiên, bạn không đăng nhập vào role, role không có password or access keys mà bạn có thể switch sang role sau khi đăng nhập bằng user của bạn. Có thể hiểu role là một tài khoản với sự uỷ nhiệm (Credentials) tạm thời để giải quyết những cồng việc khác nhau với vai trò khác nhau.\nPolicy Là 1 đối tượng khi liên kết với user, group hay role thì sẽ định nghĩa quyền của chúng.\nMọi thứ trong AWS đều là API, điều này rất quan trọng, nó cũng có nghĩa là để thực thi API, trước hết chúng ta phải xác thực, nhưng sau đó chúng ta phải ủy quyền. Đó chính là lý do vì sao chúng ta cần có Policy.\nPolicy là những file JSON được đính kèm trực tiếp vào User, Group hoặc Role. 1 Policy sẽ có dạng cấu trúc cơ bản như sau:\n { \u0026quot;Version\u0026quot;: \u0026quot;2012-10-17\u0026quot;, \u0026quot;Statement\u0026quot;: [ { \u0026quot;Sid\u0026quot;: \u0026quot;Stmt1571671788500\u0026quot;, \u0026quot;Action\u0026quot;: [ \u0026quot;ec2:CreateImage\u0026quot;, \u0026quot;ec2:CreateNetworkAcl\u0026quot;, \u0026quot;ec2:CreateNetworkAclEntry\u0026quot;, \u0026quot;ec2:CreateVpc\u0026quot; ], \u0026quot;Effect\u0026quot;: \u0026quot;Allow\u0026quot;, \u0026quot;Resource\u0026quot;: \u0026quot;*\u0026quot; }, { \u0026quot;Sid\u0026quot;: \u0026quot;Stmt1571717009297\u0026quot;, \u0026quot;Action\u0026quot;: [ \u0026quot;s3:CreateBucket\u0026quot;, \u0026quot;s3:CreateJob\u0026quot;, \u0026quot;s3:DeleteBucket\u0026quot;, \u0026quot;s3:DeleteBucketPolicy\u0026quot;, \u0026quot;s3:DeleteBucketWebsite\u0026quot;, \u0026quot;s3:DeleteObject\u0026quot; ], \u0026quot;Effect\u0026quot;: \u0026quot;Allow\u0026quot;, \u0026quot;Resource\u0026quot;: \u0026quot;*\u0026quot; } ] } Version : Phiên bản của ngôn ngữ policy\nStatement: Là thành phần chính cho một Policy. Phần tử này là bắt buộc. Statement có thể chứa một câu lệnh hoặc một mảng các câu lệnh riêng lẻ. Mỗi khối câu lệnh riêng lẻ phải được đặt trong dấu ngoặc nhọn {}. Nhiều câu lệnh, mảng phải được đặt trong dấu ngoặc vuông [].\n Sid: (statement ID) là một ID tuỳ chọn bạn cung cấp cho mỗi câu lệnh trong statement, Effect: Là 1 thành phần bắt buộc và chỉ định kết quả statement được chấp nhận hoặc từ chối (Alllow/Deny) Action: Mô tả hành động hoặc hành động cụ thể sẽ được phép hoặc bị từ chối. Resource: Chỉ định những tài nguyên AWS được áp dụng trong các Action. Condition: Chỉ định các điều kiện bắt buộc để policy có hiệu lực Với Policy, chúng ta có thể quy định rõ User, Group hay Role có quyền hạn sử dụng những tài nguyên nào.  Bạn có thể dễ dàng quản lý User, Group cũng như Role trong tài khoản AWS của mình tại mục Identity and Access Management (IAM) trên giao diện AWS Management Console.\nTóm tắt Vậy những điều chúng ta cần hiểu một cách ngắn gọn về IAM đó là:\nIAM giúp chúng ta xác thực và uỷ quyền khi sử dụng tài nguyên AWS.\nTài khoản root tạo ra các tài khoản user. Các user này thuộc về các group nhất định.\nChúng ta đăng nhập vào user, switch sang role với 1 vai trò nhất định đi kèm với các quyền sử dụng tài nguyên được quy định dựa vào policy.\nHy vọng có thể giúp mọi người hiểu về IAM.\nCảm ơn các bạn đã theo dõi blog! Hẹn gặp lại vào những blog tiếp theo!\n","description":"","id":26,"section":"posts","tags":["AWS","Devops"],"title":"[Dành cho Beginner] IAM trong AWS","uri":"https://hungpt.info/en/posts/aws_lab_1/"},{"content":"Xin chào mọi người. Hôm nay chúng ta sẽ cùng tìm hiểu về VPC (Virtual Private Cloud) trong AWS.\nTổng quan về VPC Virtual Private Cloud là gì ? Amazon Virtual Private Cloud (Amazon VPC) là dịch vụ cho phép bạn khởi chạy các tài nguyên AWS trong mạng ảo cô lập theo\nlogic mà bạn xác định.\nBạn có toàn quyền kiểm soát môi trường mạng ảo của mình, bao gồm lựa chọn dải địa chỉ IP, tạo các mạng con,\ncấu hình các bảng định tuyến và cổng kết nối mạng. Bạn có thể dùng cả IPv4 và IPv6 cho hầu hết các tài nguyên trong đám\nmây riêng ảo, giúp bảo mật nghiêm ngặt và truy cập dễ dàng các tài nguyên cũng như ứng dụng.\nLà một trong các dịch vụ nền tảng của AWS, Amazon VPC sẽ giúp bạn dễ dàng tùy chỉnh cấu hình mạng của VPC. Bạn có thể\ntạo một mạng con công khai cho các máy chủ web có quyền truy cập internet. Dịch vụ này cũng cho phép bạn đặt các hệ\nthống backend, như máy chủ ứng dụng hoặc cơ sở dữ liệu, trong mạng con riêng tư không có quyền truy cập internet. Với\nAmazon VPC, bạn có thể sử dụng nhiều lớp bảo mật, bao gồm các nhóm bảo mật và danh sách kiểm soát truy cập mạng, để giúp\nkiểm soát quyền truy cập vào các phiên bản Amazon EC2 trong mỗi mạng con.\n","description":"","id":27,"section":"posts","tags":["VPC","AWS","Devops","CI/CD"],"title":"[Dành cho Beginner] VPC trong AWS","uri":"https://hungpt.info/en/posts/vpc_in_aws/"},{"content":"Mình sẽ quay trở lại sớm với loại bài về K8s nhé 😄…\n","description":"","id":28,"section":"posts","tags":["Devops","AWS"],"title":"[K8S] - Phần 1: K8S là gì ?","uri":"https://hungpt.info/en/posts/k8s_la_gi_part1/"},{"content":"Trong bài viết lần này chúng ta sẽ cùng hiểu 2 thuật ngữ Mount và Unmount. Trong đó Mount có nghĩa là gắn vào, Unmount\nnghĩa là tháo ra gỡ ra.\nĐây là 2 thuật ngữ chúng ta sẽ dùng rất nhiều khi làm việc với Reactjs, cụ thể làm làm việc với component.\nĐể ví dụ cho các bạn về 2 thuật ngữ này mình sẽ tạo ra một component được viết trong file Content.js như sau:\n1 2 3 4 5 6  function Content() { return ( \u0026lt;h1\u0026gt; Xin chao \u0026lt;/h1\u0026gt; ) } export default Content   Sau đó mình sẽ thêm component Content này vào file App.js như sau:\n1 2 3 4 5 6 7 8 9 10  import Content from \u0026#34;./Content\u0026#34;; function App() { return ( \u0026lt;div style={{padding: 32}}\u0026gt; \u0026lt;Content/\u0026gt; \u0026lt;/div\u0026gt; ) } export default App;   Bây giờ mình sẽ thêm 1 state vào để quyết định việc ẩn hiện của component Content này,sau đó thêm 1 button click để ẩn hiện nó\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import {useState} from \u0026#34;react\u0026#34;; import Content from \u0026#34;./Content\u0026#34;; function App() { const [show,setShow] = useState(false) return ( \u0026lt;div style={{padding: 32}}\u0026gt; \u0026lt;button onClick={()=\u0026gt;setShow(!show)}\u0026gt; Click \u0026lt;/button\u0026gt; {show \u0026amp;\u0026amp; \u0026lt;Content/\u0026gt;} \u0026lt;/div\u0026gt; ) } export default App;   Để dễ hình dung hơn, mình có hình dưới đây\nmount_unmount\nKhi chúng ta click vào button, dòng \u0026lt;h 1\u0026gt; Xin chao \u0026lt;/h 1\u0026gt; sẽ được mount và unmount vào trong DOM. Thực chất mình lấy ví dụ trong DOM là cho các bạn dễ hình dung\nthực ra element cho tới khi được render vào DOM thì thật ra là bước sau của mount rồi 😄.\nHành vi Mount và Unmount được diễn ra trước đó rồi, thì tại sao lại như vậy? Đó là vì khi chúng ta click button, function App\nsẽ được chạy lại, khi biến show = True thì component Content được gọi, thì tại thời điểm component Content được đưa vào React Element để\nsử dụng thôi thì quá trình Mount đã xảy ra ngay thời điểm này rồi.\nChú ý nhỏ : thực ra ngay bản thân App.js cũng đã được Mount khi chúng ta f5 trình duyệt đó 😄 bạn thử tìm hiểu thêm tại sao lại như vậy nha.\n","description":"","id":29,"section":"posts","tags":["Reactjs","Javascript"],"title":"Mounted \u0026 Unmounted?","uri":"https://hungpt.info/en/posts/mount_and_unmount/"},{"content":"Trong bài viết lần này, chúng ta hãy cùng tìm hiểu 1 hook mới trong ReactJS là useMemo và 1 HOC trong ReactJS là memo nhé!😄\nTrong quá trình làm việc với React, chúng ta sẽ có lựa chọn như:\n Hooks render props higher-order-components (HOCs)\nMình sẽ nói cụ thể hơn 3 phần này khác gì nhau ở bài viết sau nhé 😄  1. memo trong ReactJS mình có 1 đoạn code đơn giản như sau\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import {useState} from \u0026#34;react\u0026#34;; import {useEffect} from \u0026#34;react\u0026#34;; import Content from \u0026#34;./Content\u0026#34;; import Chat_content from \u0026#34;./chat_fake/Chat_content\u0026#34;; import UseRef from \u0026#34;./use_ref/UseRef\u0026#34;; import Memo_content from \u0026#34;./memo/Memo_content\u0026#34;; function App() { const [show, setShow] = useState(false) const [number, setNumber] = useState(1) const handleSetnumber = () =\u0026gt; { setNumber(number+1) } return ( \u0026lt;div style={{padding: 32}}\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Memo_content/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {number} \u0026lt;/div\u0026gt; \u0026lt;button onClick={handleSetnumber}\u0026gt; Click \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App;   Và đây là code của component Memo_content\n1 2 3 4 5 6 7 8 9 10 11 12  import {memo, useEffect, useState} from \u0026#34;react\u0026#34;; function Memo_content() { console.log(\u0026#39;render\u0026#39;) return ( \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; ) } export default Memo_content;   Chúng ta có thể thấy, mỗi khi click đẩ thay đổi state của component cha thì component con là Memo_content cũng được\nrender lại mặc dù component con không có gì thay đổi. Vậy chúng ta sẽ xử lý vấn đề này như thế nào?\nRất đơn giản, bạn chỉ cần thêm memo để wrap lại component con như sau:\n1  export default memo(Memo_content);   Thông thường với những component nặng về xử lý logic như biểu đồ, dashboard mà chúng ta không muốn render lại\ncomponent thì nên dùng cách này, còn thông thường việc này cũng không quá quan trọng 😄 theo mình là như vậy\n2. useMemo trong ReactJS Vậy khi nào chúng ta sử dụng useMemo? ĐÓ là khi chúng ta không muốn thực hiện lại 1 logic nào đó không cần thiết.\nVậy khi nào là không cần thiết? Chúng ta hãy cùng tìm hiểu qua 1 ví dụ đơn giản mình đưa ra ở dưới đây nhé!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  import {useState} from \u0026#34;react\u0026#34;; function App() { const [name, setName] = useState(\u0026#39;\u0026#39;) const [price, setPrice] = useState(\u0026#39;\u0026#39;) const [products, setProducts] = useState([]) const handleSubmit = () =\u0026gt; { setProducts([...products,{ name, price: +price }]) } const total = products.reduce((result, pro) =\u0026gt; { console.log(\u0026#39;bi tinh toan lai\u0026#39;) return result + pro.price },0 ) return ( \u0026lt;div style={{ padding: \u0026#39;10px 200px\u0026#39; }}\u0026gt; \u0026lt;input value={name} placeholder=\u0026#39;Enter name...\u0026#39; onChange={event =\u0026gt; setName(event.target.value)} /\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input value={price} placeholder=\u0026#39;Enter price...\u0026#39; onChange={event =\u0026gt; setPrice(event.target.value)} /\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;button onClick={handleSubmit} \u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; Total : {total} \u0026lt;ul\u0026gt; { products.map((product, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{product.name} - {product.price}\u0026lt;/li\u0026gt; )) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default App;   Về cơ bản ứng dụng đơn giản là như vậy😄\nTuy nhiên nếu như bạn để ý, hàm tính toán ra price của mình luôn bị gọi khi chúng ta nhập\ngiá trị vào ô price, mặc dù khi đó chúng ta chưa cần tính lại total. Và đây là\nlúc chúng ta sử dụng useMemo như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  import {useState, useMemo} from \u0026#34;react\u0026#34;; function App() { const [name, setName] = useState(\u0026#39;\u0026#39;) const [price, setPrice] = useState(\u0026#39;\u0026#39;) const [products, setProducts] = useState([]) const handleSubmit = () =\u0026gt; { setProducts([...products,{ name, price: +price }]) } const total = useMemo(() =\u0026gt; { const total = products.reduce((result, pro) =\u0026gt; { console.log(\u0026#39;bi tinh toan lai\u0026#39;) return result + pro.price },0 ) },[products]) return ( \u0026lt;div style={{ padding: \u0026#39;10px 200px\u0026#39; }}\u0026gt; \u0026lt;input value={name} placeholder=\u0026#39;Enter name...\u0026#39; onChange={event =\u0026gt; setName(event.target.value)} /\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input value={price} placeholder=\u0026#39;Enter price...\u0026#39; onChange={event =\u0026gt; setPrice(event.target.value)} /\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;button onClick={handleSubmit} \u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; Total : {total} \u0026lt;ul\u0026gt; { products.map((product, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{product.name} - {product.price}\u0026lt;/li\u0026gt; )) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default App;   Tương tự như useEffect và useCallback, useMemo cũng nhận 2 đối số,\nđối số thứ nhất là 1 callback, đối số thứ 2 là 1 dependencies, nguyên tắc hoạt động\ncủa dependencies cũng tương tự như useEffect và useCallback.\nHy vọng bài viết sẽ giúp ích cho bạn 😀, hẹn gặp lại mọi người ở những bài viết sau.\n","description":"","id":30,"section":"posts","tags":["ReactJS","Javascript"],"title":"Cách sử dụng useMemo và memo trong ReactJS","uri":"https://hungpt.info/en/posts/use_memo_in_reactjs/"},{"content":"Trong bài viết lần này, chúng ta hãy cùng tìm hiểu 1 hook mới trong ReactJS là useRef nhé!😄\nVậy useRef được sử dụng khi nào? Và mục đích sử dụng của hook này là gì?\nĐầu tiên mình sẽ xây dựng 1 ứng dụng đếm ngược đơn giản như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  import {useState, useEffect, useRef} from \u0026#34;react\u0026#34;; function Content() { const [number, setNumber] = useState(9000) const handle_start = () =\u0026gt; { setInterval(() =\u0026gt; { setNumber(preNumber =\u0026gt; preNumber - 1) },100) } const handle_stop = () =\u0026gt; { } return ( \u0026lt;div\u0026gt; \u0026lt;div style={ {\u0026#39;fontSize\u0026#39;: \u0026#39;100px\u0026#39;} }\u0026gt; {number} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button onClick={handle_start} \u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={handle_stop} \u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content;   Giao diện đơn giản nó sẽ như thế này 😄\nBài toán mình sẽ đi giải quyết ở đây là sau khi bấm nút stop thì ứng dụng đếm số sẽ ngừng lại tại con số hiện thời. Chúng ta đã setInterval ở button start,\nvậy để stop chúng ta chỉ cần clearInterval ở button stop thôi. Nhưng function clearInterval() nhận đối số truyền vào là ID hiện thời\nCách đơn giản là chúng ta sẽ thêm 1 biến là timeID và truyền cho giá trị mỗi khi setState lại như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  import {useState, useEffect, useRef} from \u0026#34;react\u0026#34;; function Content() { const [number, setNumber] = useState(9000) let timeId const handle_start = () =\u0026gt; { setInterval(() =\u0026gt; { timeId = setNumber(preNumber =\u0026gt; preNumber - 1) },100) console.log(\u0026#39;start\u0026#39;, timeId) } const handle_stop = () =\u0026gt; { clearInterval(timeId) console.log(\u0026#39;stop\u0026#39;, timeId) } return ( \u0026lt;div\u0026gt; \u0026lt;div style={ {\u0026#39;fontSize\u0026#39;: \u0026#39;100px\u0026#39;} }\u0026gt; {number} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button onClick={handle_start} \u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={handle_stop} \u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content;   Nhưng bài toán vẫn chưa được giải quyết? Chúng ta thử xem log timeID hiển thị trước và sau thế nào nhé!\nVậy là biến timeID không được lưu lại? Tại sao lại như vậy? Đó là bởi vì biến timeID của chúng ta nằm trong component và mỗi khi state thay đổi component\nsẽ render lại dẫn đến biến *** timeID*** sẽ được set lại giá trị lại.\nĐể giải quyết định vấn đề này chúng ta có thể cho biến timeID ra ngoài function component, khi đó, bài toán của chúng ta sẽ được giải quyết\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  import {useState, useEffect, useRef} from \u0026#34;react\u0026#34;; let timeId function Content() { const [number, setNumber] = useState(9000) const handle_start = () =\u0026gt; { timeId = setInterval(() =\u0026gt; { setNumber(preNumber =\u0026gt; preNumber - 1) },1000) console.log(\u0026#39;start\u0026#39;, timeId) } const handle_stop = () =\u0026gt; { clearInterval(timeId) console.log(\u0026#39;stop\u0026#39;, timeId) } return ( \u0026lt;div\u0026gt; \u0026lt;div style={ {\u0026#39;fontSize\u0026#39;: \u0026#39;100px\u0026#39;} }\u0026gt; {number} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button onClick={handle_start} \u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={handle_stop} \u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content;   Tuy nhiên với ReactJS chúng ta không nên làm thế 😄 có nhiều nguyên nhân……nên ở đây chúng ta sẽ sử dụng useRef.\nKhi chúng ta dùng useRef để lưu giá trị, thì khi phải render lại một function component, giá trị đã lưu sẽ không bị thay đổi, mà vẫn giữ được giá trị đã lưu trước đó.\n useRef(initialValue) chấp nhận đối số là giá trị đầu vào và trả về một tham chiếu. Tham chiếu là một object đặc biệt có 1 thuộc tính là current: reference.current Có 2 điều cần nhớ về useRef là:  Gía trị của reference sẽ được giữ nguyên khi component re-render Việc update reference sẽ không làm cho component re-render   Tới đây có thể thấy useRef() khá giống với state trong việc save 1 value, nhưng điểm khác nhau là khi set lại state thì\ncomponent re-render, còn với useRef() thì không. Một điểm nữa là state update sẽ chạy bất đồng bộ, còn với useRef() sẽ update ngay lập tức vì được chạy đồng bộ.\nMình sẽ sửa lại code sử dụng useRef như sau:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  import {useState, useEffect, useRef} from \u0026#34;react\u0026#34;; function Content() { const [number, setNumber] = useState(9000) const ref = useRef(99) let timeId = useRef(99) const handle_start = () =\u0026gt; { timeId.current = setInterval(() =\u0026gt; { setNumber(prevNumber =\u0026gt; prevNumber - 1) }, 1000) console.log(\u0026#39;start\u0026#39;, timeId.current) } const handle_stop = () =\u0026gt; { clearInterval(timeId.current) console.log(\u0026#39;stop\u0026#39;, timeId.current) } return ( \u0026lt;div\u0026gt; \u0026lt;div style={ {\u0026#39;fontSize\u0026#39;: \u0026#39;100px\u0026#39;} }\u0026gt; {number} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button onClick={handle_start} \u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={handle_stop} \u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content;   Lưu ý: Hạn chế việc sử dụng useRef mà thay vào đó nên sử dụng state, chỉ khi không thể sử dụng được state thì mới dùng useRef(), như trường hợp tuy cập DOM.\nHi vọng bài viết sẽ giúp ích được các bạn hiểu rõ hơn khi nào thì sử dụng nó và áp dụng vào từng trường hợp cụ thể. Nếu có bất kì thắc mắc hay góp ý nào xin comment phía dưới. Mình xin cảm ơn!\n","description":"","id":31,"section":"posts","tags":["Reactjs","Javascript"],"title":"Cách sử dụng useRef trong ReactJS","uri":"https://hungpt.info/en/posts/use_ref/"},{"content":"Gỉa sử chúng có một mảng các chữ số như sau:\n1  const numbers = [2, 4, 6];   Làm sao chúng ta có thể tính tổng các chữ số trong mảng trên. Sử dụng reduce trong javascript chúng ta có dễ dàng làm việc này mà không cần sử dụng vòng lặp.\n1 2 3 4 5 6  const numbers = [2, 4, 6]; const sum = numbers.reduce(function(sum, number) { const updatedSum = sum + number; return updatedSum; }, 0); sum; // 12   Trong bài viết này, chúng ta sẽ tìm hiểu về phương thức reduce và cách sử dụng array.reduce(callback, initialValue)\n1.Phương thức reduce Trước khi đi sâu hơn về cách sử dụng array.reduce() chúng ta hãy cùng tìm hiểu reduce được sử dụng làm mục đích gì? Đó chính là giảm kích thước của 1 mảng thành\n1 giá trị duy nhất.\nMột ví dụ khác của việc này là xác đinh phần từ lớn nhất của mảng [7,2,10,6] kết quả ở đây sẽ là 10.\nQua đó chúng ta có thể thấy được rằng phương thức reduce() mục đích là để thực hiện thao tác rút gọn phần tử trong mảng.\n2.Array.reduce() Array.reduce() có 2 đối số truyền vào:\n1  const value = array.reduce(callback[, initialValue]);   Trong đó callback là đối số bắt buộc, initialValue không bát buộc và làm giá trị khởi tạo.\nJavascript gọi callback trên mỗi phần tử của mảng với 4 đối số (giá trị tích lũy, phần tử hiện tại của mảng, index của phần tử hiện tại trong mảng, mảng chính)\n1 2 3 4 5  array.reduce(function(accumulator, item, index, array) { // Use `accumulator` and `item`  // to calculate `updatedAccumulator`...  return updatedAccumulator; })   Một ví dụ cụ thể hơn:\n1 2 3 4 5 6  const numbers = [2, 4, 6]; const sum = numbers.reduce(function summarize(sum, number) { const updatedSum = sum + number; return updatedSum; }, 0); sum; // 12   numbers.reduce(summarize, 0) dùng để tính tổng tất cả các phần tử trong mảng\nNgoài ra hãy lưu ý đối số thứ 2 numbers.reduce(summarize, 0) đó là tổng các phần tử trong mảng được gán mặc định ban đầu là 0.\nVậy làm cách nào để tìm phần tử lớn nhất trong mảng khi chúng ta sử dụng reduce()? Bạn hãy tìm hiểu xem sao nhé? 😄\n3. Bỏ qua giá trị khởi tạo ban đầu (initialValue) Giá trị này sẽ được khởi tạo cho previousValue ở lần thực thi đầu tiên. Nếu bạn truyền 1 initialValue thì currentValue sẽ được khởi tạo là giá trị đầu tiên của mảng.\nNếu không truyền initialValue thì previousValue được khởi tạo là giá trị đầu của mảng và vì thế currentValue sẽ là giá trị thứ hai của mảng.\nĐể dễ hiểu hơn thì chúng ta cùng xem một ví dụ:\n1 2 3  [0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, currentIndex, array) { return previousValue + currentValue // 10 })   Đếm số lần xuất hiện phần tử trong mảng Một cách để đếm số lần xuất hiện của phần tử khá hay chính là dùng reduce 😁.\n1 2 3 4 5 6 7 8 9  let names = [\u0026#39;John\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Jonas\u0026#39;, \u0026#39;Bruce\u0026#39;, \u0026#39;John\u0026#39;] let count = names.reduce(function (allNames, name) { if (name in allNames) allNames[name]++ else allNames[name] = 1 return allNames }, {}) // { \u0026#39;John\u0026#39;: 2, \u0026#39;Bob\u0026#39;: 1, \u0026#39;Jonas\u0026#39;: 1, \u0026#39;Bruce\u0026#39;: 1 }   ","description":"","id":33,"section":"posts","tags":["Reactjs","Javascript"],"title":"Tìm hiểu về phương thức Reduce trong Javascript","uri":"https://hungpt.info/en/posts/javascript-array-reduce/"},{"content":"useEffect là 1 hook cơ bản trong Reactjs, nhưng khi bạn mới học sẽ thấy nó hơi khó một chút😁. Lý do nó khó không phải vì hook\nnày nó khó mà vì để có thể sử dụng được hook này đòi hỏi bạn phải nắm vững kiến thức Javascript cơ bản và nâng cao. Thế nên\nnếu bạn đi vào đây học quá nhanh hoặc quên mất kiến thức nền thì học sẽ bị khó.\nỞ đây mình sẽ review cho bạn một số kiến thức mà bạn nên nắm chắc khi học hook này:\n Events : Bạn nên biết cách làm việc với event trong javascript, bao gồm cả Dom event và custom event do bạn tạo ra, biết cách sử dụng add/remove event listener, hiểu tại sao phải remove event listener Observer parttern : (Subscribe/unsubcribe) Đây là 1 dạng triển khai mở rông của tư tưởng add/remove listener, bản chất cũng là dạng đầu tiên nhưng triển khai ở 1 dạng khác Bạn cần nắm rõ khái niệm hàm đóng Closure trong Javascript. Biết cách làm việc với api dạng timer như setInterval, setTimeout, clearInterval, ClearTimeout. Nắm chắc hook useState. Hiểu rõ khi nào mounted, khi nào unmounted.  Hook này để làm gì và chúng ta dùng nó khi nào? Chúng ta sẽ dùng useEffect khi các bạn muốn thực hiện các side effect, thuật ngữ này được sử dụng chung trong lĩnh vực phần mềm,\nside effect đang nói tới 1 chương trình phần mềm khi có 1 tác động xảy ra dẫn đến dữ liệu bị thay đổi. Mình sẽ đưa\ncho bạn một vài ví du quen thuộc để bạn dễ hình dung đó là khi bạn update DOM, call api nhận lại dữ liệu để setState….\nTóm lại useEffect sẽ giúp các bạn update DOM, call API, listen DOM event, remove event listener…\nuseEffect có 3 tình huống chính khi chúng ta sử dụng:\n useEffect(callback) useEffect(callback,[]) useEffect(callback,[deps])\nHãy cùng mình đi tìm hiểu từng tình huống và xem cách useEffect hoạt động như thế nào nhé!  1. useEffect(callback) Với trường họp này, callback sẽ được gọi mỗi khi component được mounted vào trong DOM\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import {useState} from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react\u0026#34;; import Content from \u0026#34;./Content_blog\u0026#34;; function App() { const [show,setShow] = useState(false) return ( \u0026lt;div style={{padding: 32}}\u0026gt; \u0026lt;button onClick={()=\u0026gt;setShow(!show)}\u0026gt; Click \u0026lt;/button\u0026gt; {show \u0026amp;\u0026amp; \u0026lt;Content/\u0026gt;} \u0026lt;/div\u0026gt; ) } export default App;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import { useEffect } from \u0026#34;react\u0026#34;; import {useState} from \u0026#34;react\u0026#34;; function Content() { const [title, setTitle] = useState(\u0026#39;\u0026#39;) useEffect(() =\u0026gt; { console.log(\u0026#39;test12\u0026#39;) }); return ( \u0026lt;div\u0026gt; \u0026lt;input value={title} onChange={(e)=\u0026gt; setTitle(e.target.value)} z /\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content   ở đây mình có viết 1 useEffect mỗi khi mình click button thì ô input sẽ được hiển thị\nNhư bạn có thể thấy mỗi khi click button, component sẽ được render lại =\u0026gt; dẫn tới việc callback trong trường hợp useEffect\nnày sẽ được gọi lại, bạn có thể thấy log bên dưới tab console.\nTuy nhiên trường hợp đầu tiên này được sử dụng khá ít trong thực tế và khi sử dụng trường hợp này để call API update lại DOM cũng sẽ xảy ra một điều 😃 cùng mình\nxem đó là gì nhé!\nBây giờ mình sẽ call 1 api và update DOM, api mình sẽ lấy ở https://jsonplaceholder.typicode.com.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  import { useEffect } from \u0026#34;react\u0026#34;; import {useState} from \u0026#34;react\u0026#34;; function Content() { const [title, setTitle] = useState(\u0026#39;\u0026#39;) const [posts, setPosts] = useState([]) useEffect( () =\u0026gt;{ fetch(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;) .then(res =\u0026gt; res.json()) .then(posts =\u0026gt;{ setPosts(posts) }) } ) return ( \u0026lt;div\u0026gt; \u0026lt;input value={title} onChange={(e)=\u0026gt; setTitle(e.target.value)} z /\u0026gt; \u0026lt;ul\u0026gt; {posts.map(post =\u0026gt;( \u0026lt;li key={post.id}\u0026gt;{post.title}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content   Có vẻ mọi thứ đã hoạt động rồi nhỉ, tuy nhiên bạn hãy cũng nhìn tab network với mình nhé!\nAPI được gọi liên tục trong 1 vòng lặp vô hạn. Tại sao lại như vậy? Đó chính là khi gọi API xong, chúng ta gọi lại hàm setPost(), dẫn tới việc component\nđược render lại và rồi theo như lý thuyết của useEffect là callback sẽ được gọi mỗi khi component được mounted vào trong DOM dẫn tới việc xảy ra vòng lặp\nvô hạn ở đây. Chính điều này là nguyên nhân mà chúng ta cần sử dụng useEffect với 2 trường hợp còn lại hoặc còn gọi chung là useEffect với dependencies.\n","description":"","id":34,"section":"posts","tags":["Reactjs","Javascript"],"title":"Cách sử dụng useEffect trong ReactJS (Phần 1)","uri":"https://hungpt.info/en/posts/use_effect_part1/"},{"content":"Ở phần 1, chúng ta đã tìm hiểu về trường hợp đầu tiên sử dụng useEffect, cùng hiểu tại sao phải sử dụng tham số thứ 2 trong useEffect. Trong\nphần này chúng ta sẽ tìm hiểu rõ hơn.\nĐể có thể xử lý vấn đề api call liên tục k dừng ở phần 1, bạn chỉ cần thêm tham số thứ 2 trong useEffect có thể là 1 mảng rỗng []\nhoặc 1 mảng có giá trị [post…]\n1 2 3 4 5 6 7 8 9  useEffect( () =\u0026gt;{ fetch(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;) .then(res =\u0026gt; res.json()) .then(posts =\u0026gt;{ setPosts(posts) }) },[] )   Vậy trong trường hợp dependency array không phải mảng rỗng thì sao?\nNếu mảng này có phần tử, mỗi khi giá trị của phần tử thay đổi, call back của useEffect sẽ được gọi lại. Ví dụ trong đoạn code này mình sẽ sửa lại 1 chút như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  import { useEffect } from \u0026#34;react\u0026#34;; import {useState} from \u0026#34;react\u0026#34;; const tabs = [\u0026#39;posts\u0026#39;,\u0026#39;comments\u0026#39;,\u0026#39;albums\u0026#39;] function Content() { const [title, setTitle] = useState(\u0026#39;\u0026#39;) const [posts, setPosts] = useState([]) const [types, setTypes] = useState([\u0026#39;posts\u0026#39;]) useEffect( () =\u0026gt;{ console.log(\u0026#39;title changed\u0026#39;) document.title = title; fetch(`https://jsonplaceholder.typicode.com/${types}`) .then(res =\u0026gt; res.json()) .then(posts =\u0026gt;{ setPosts(posts) }) },[types] ) return ( \u0026lt;div\u0026gt; {tabs.map(tab =\u0026gt; ( \u0026lt;button style={types ===tab ? { color : \u0026#39;#fff\u0026#39;, backgroundColor : \u0026#39;black\u0026#39; } : { coler : \u0026#39;fff\u0026#39;, backgroundColor : \u0026#39;blue\u0026#39; }} key={tab} onClick={() =\u0026gt;setTypes(tab)} \u0026gt;{tab}\u0026lt;/button\u0026gt; ))} \u0026lt;input value={title} onChange={(e)=\u0026gt; setTitle(e.target.value)} z /\u0026gt; \u0026lt;ul\u0026gt; {posts.map(post =\u0026gt;( \u0026lt;li key={post.id}\u0026gt;{post.title}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content   Mình đã thêm 3 button, khi click vào từng button sẽ gọi API tương ứng, để có thể làm được điều này mình đã thêm 1 state là types, mỗi\nkhi click vào từng button, mình sẽ dùng useState để set lại giá trị tương ứng, khi có giá trị rồi mình sẽ truyền vào API để call.\nNhư vập sau khi giá trị của types thay đổi, callback của useEffect sẽ được gọi lại.\nỞ phần tiếp theo chúng ta sẽ tìm hiểu về useEffect với listen DOMEvent nhé! 😃\n","description":"","id":35,"section":"posts","tags":["Reactjs","Javascript"],"title":"Cách sử dụng useEffect trong ReactJS (Phần 2)","uri":"https://hungpt.info/en/posts/use_effect_part2/"},{"content":"Nội dung ở phần này mình muốn đưa cho các bạn sẽ có 3 phần chính:\n Cách listen DOMEvent trong React component Vấn để xảy ra khi chúng ta listen DOM Event là gì? Cách khắc phục vấn đề nàymột  Trong phần này, chúng ta phải nắm vững kiến thức Javascript cơ bản đó là listen DOM Event bạn có thể tham khảo tài liệu tại đây Listen DOM Event\nMình sẽ xác định rõ ngay từ đầu là khi thực hiện một logic mới, chúng ta sẽ viết ra 1 useEffect mới\nBây giờ chúng ta sẽ làm 1 ví dụ, đó là khi chúng ta cuộn chuột xuống 1 khoảng lớn hơn hoặc = 200 px thì sẽ hiện 1 nút Go to top\nđể hiện lên trang đầu, như trong blog này của mình cũng có tính năng này.\nỞ trường hợp này chúng ta sẽ đi listenDOM 1 lần, khi đó chúng ta sẽ truyền dependencies vào là []\n1 2 3 4 5 6  useEffect(() =\u0026gt; { const handleScroll = () =\u0026gt;{ console.log(window.scrollY) } window.addEventListener(\u0026#39;scroll\u0026#39;, handleScroll) }, [])   ở đây chúng ta sẽ code Javascript thuần, để có thể ẩn hiện được button go to top, chúng ta cần phải re render lại giao diện, với ReactJs chúng ta sẽ dùng hoook\nuseState mà chúng ta đã tìm hiểu ở các phần trước.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function Content() { const [title, setTitle] = useState(\u0026#39;\u0026#39;) const [posts, setPosts] = useState([]) const [types, setTypes] = useState([\u0026#39;posts\u0026#39;]) const [showGoToTop, setShowGoToTop] = useState(false) useEffect( () =\u0026gt;{ console.log(\u0026#39;title changed\u0026#39;) document.title = title; fetch(`https://jsonplaceholder.typicode.com/${types}`) .then(res =\u0026gt; res.json()) .then(posts =\u0026gt;{ setPosts(posts) }) },[types] ) useEffect(() =\u0026gt; { const handleScroll = () =\u0026gt;{ if(window.scrollY \u0026gt;= 200){ setShowGoToTop(true) }else{ setShowGoToTop(false) } } window.addEventListener(\u0026#39;scroll\u0026#39;, handleScroll) }, [])   Sau đó mình sẽ viết 1 đoạn code để ẩn hiện button go to top theo state bên trên\n1 2 3 4 5 6 7 8 9  {showGoToTop \u0026amp;\u0026amp; ( \u0026lt;button style={{ position: \u0026#39;fixed\u0026#39;, right: 20, bottom: 20 }}\u0026gt; Go to top \u0026lt;/button\u0026gt; )}   Và kết quả sẽ như sau:\nTuy nhiên nếu các bạn để ý thì chúng ta sẽ thấy rằng, nếu chúng ta tiếp tục kéo chuột xuống thì useEffect sẽ liên tục được gọi\ndẫn tới việc liên tục re render lại giao diện? Câu trả lời là không, ReactJS đã giúp chúng ta ngăn chặn việc đó. Có nghĩ là mặc dù hàm trong useEffect được gọi lại liên tục nhưng\ncomponent sẽ không bị re render lại.\nĐến với 1 vấn đề tiếp theo, bây giờ chúng ta thử unmount component rồi mount lại, xong đó kéo chuột xuống, sẽ có 1 thông báo mà ReactJS báo cho chúng ta như sau:\nĐó là bởi vì khi component của chúng ta unmount thì Event Listen chúng ta thêm vào chưa được xóa đi, dẫn tới việc khi chúng ta mount lại component thì 1 event\nlisten nữa lại được thêm vào, điều này dẫn đến lãng phí tài nguyên, dò rỉ bộ nhớ. Vậy giải pháp ở đây là gì? Đó chính là Cleanup Function và trong callback\ncủa useEffect các bạn có thể return ra 1 hàm\n1 2 3 4 5 6 7 8 9 10 11 12  useEffect(() =\u0026gt; { const handleScroll = () =\u0026gt;{ if(window.scrollY \u0026gt;= 200){ setShowGoToTop(true) }else{ setShowGoToTop(false) } } window.addEventListener(\u0026#39;scroll\u0026#39;, handleScroll) // cleanup function  return () =\u0026gt; window.removeEventListener(\u0026#39;scroll\u0026#39;, handleScroll) }, [])   Hy vọng sau phần này bạn sẽ nắm rõ cách xử lý DOM event trong Reactjs 😄. Bye bye\n","description":"","id":36,"section":"posts","tags":["Reactjs","Javascript"],"title":"Cách sử dụng useEffect trong ReactJS (Phần 3)","uri":"https://hungpt.info/en/posts/use_effect_part3/"},{"content":"Ở phần này, mình sẽ xây dựng app chat đơn giản để có thể giúp các bạn nắm rõ hơn cách sử dụng useEffect như thế nào nhé!😄\nỞ đây mình sẽ không tạo web socket server mà mình sẽ đi fake ra những bình luận\n","description":"","id":37,"section":"posts","tags":["Reactjs","Javascript"],"title":"Cách sử dụng useEffect trong ReactJS (Phần 4)","uri":"https://hungpt.info/en/posts/use_effect_part4/"},{"content":"ReactJS là một Javascript framework rất phổ biến với giới lập trình Web Frontend hiện nay, số lượng tuyển dụng lập trình viên ReactJS cũng rất lớn. Do đó nhiều người mới học Web Frontend sau khi học xong một chút HTML CSS JS là muốn nhảy vào lập trình ReactJS ngay. Điều này dẫn đến hệ lụy là các bạn sẽ bị hổng kiến thức cơ bản, hoặc khi học ReactJS sẽ rất chật vật vì không hiểu cú pháp, không hiểu bản chất, …\nVậy trước khi học ReactJS hoặc React Native, các bạn nên nẵm vững HTML CSS và những kiến thức sau trong JavaScript (ngoài các kiến thức ban đầu như biến, vòng lặp, điều kiện, …):\nCác hàm xử lý mảng như map, filter, reduce, push, splice, …\nES6/ES7 Class (mặc dù hiện tại code ReactJS đang dần chuyển sang hướng function nhưng vẫn nên biết).\nVariable scope và closure Cần nắm vững khái niệm Scope (code block, nested function, …) trong Javascript. Khai báo biến thì sử dụng let thay cho var (kiểu cũ), với hằng số hoặc magic number thì dùng const.\nKhái niệm closure thì hơi khó hiểu nhưng cũng nên tìm hiểu trước để khi gặp không bị bỡ ngỡ 😅.\nImport và Exports Trong các project chúng ta sẽ có nhiều file để đảm bảo code ngắn gọn và dễ bảo trì. Cần chú ý giữa named export và default export.\nVí dụ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /* * File util.js */ // export một mảng export let month = [ \u0026#34;Jan\u0026#34;, \u0026#34;Feb\u0026#34;, \u0026#34;Mar\u0026#34;, \u0026#34;Apr\u0026#34;, \u0026#34;Aug\u0026#34;, \u0026#34;Sep\u0026#34;, \u0026#34;Oct\u0026#34;, \u0026#34;Nov\u0026#34;, \u0026#34;Dec\u0026#34;, ]; // export một hằng số export const YEAR = 2020; // export một class export class User { constructor(name) { this.name = name; } }   Arrow function Arrow function được sử dụng khá nhiều bởi cách viết ngắn gọn và không có “this”.\nVí dụ với function thông thường:\n1 2 3  function sum(a, b) { return a + b; }   Viết lại bằng arrow function:\n1  const sum = (a, b) =\u0026gt; a + b;   Destructuring assignment Là cú pháp cho phép tách các object, array ra thành các biến, giúp cho code ngắn gọn hơn thay vì khai báo biến nhiều lần. Ví dụ hay sử dụng trong ReactJS:\n1 2 3 4 5 6 7 8 9 10 11 12  // Không sử dụng destructuring assignment function MyComponent(props) { let navigation = props.navigation; let route = props.route; ... } // Sử dụng destructuring assignment function MyComponent({navigation, route}) { ... }   Hoặc khi sử dụng useState hook:\n1 2 3  function MyComponent() { const [count, setCount] = React.useState(0); }   Rest parameters and spread syntax Rest parameters cho phép chúng ta viết 1 hàm với số lượng tham số là linh động (không biết trước). Ví dụ:\n1 2 3 4 5 6 7 8 9 10 11 12  function sumAll(...args) { // args là tên biến đại diện cho mảng các tham số  let sum = 0; for (let arg of args) sum += arg; return sum; } alert(sumAll(1)); // 1 alert(sumAll(1, 2)); // 3 alert(sumAll(1, 2, 3)); // 6   hoặc:\n1 2 3 4 5 6 7 8 9 10 11  function showName(firstName, lastName, ...otherNames) { alert(firstName + \u0026#34; \u0026#34; + lastName); // Robin Huy  // Rest parameters ...otherNames đại diện cho các tham số còn lại ngoài 2 tham số đầu tiên  // ví dụ ở đây otherNames sẽ là [\u0026#34;Robin\u0026#34;, \u0026#34;Huy\u0026#34;]  alert(otherNames[0]); // Chris  alert(otherNames[1]); // Robert  alert(otherNames.length); // 2 } showName(\u0026#34;Robin\u0026#34;, \u0026#34;Huy\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Robert\u0026#34;);   Spread syntax có cú pháp và cách hoạt động gần giống như rest parameters, nó cho phép “duỗi” một object hoặc array ra thành nhiều biến. Ví dụ:\n1 2 3 4 5 6 7  // Hàm Math.max cần truyền vào các số để tính max alert(Math.max(1, 3, 5, 2)); // Trả về 5  // Tuy nhiên nếu có 1 mảng các số thì chúng ta có thể spread mảng đó ra để sử dụng hàm Math.max const numbers = [1, 3, 5, 2]; alert(Math.max(numbers)); // Trả về NaN alert(Math.max(...numbers)); // Trả về 5   Các hàm xử lý mảng Code ReactJS sẽ phải làm việc với mảng rất nhiều nên phải sử dụng thành thạo các phương thức xử lý mảng như: map, filter, reduce, push, splice, …\nVí dụ sử dụng phương thức map kết hợp arrow function:\n1 2  const numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((number) =\u0026gt; number * 2);   Hoặc sử dụng filter để lọc phần tử ra khỏi mảng:\n1 2 3 4 5 6  // Xóa 1 sản phẩm ra khỏi mảng các sản phẩm dựa theo ID truyền vào function removeProduct(productId) { const newProducts = products.filter((product) =\u0026gt; product.id !== productId); setProducts(newProducts); }   Trên đây là một vài kiến thức cơ bản mình nghĩ newbie cần phải biết trước khi học ReactJS. Nếu các bạn thấy còn thiếu thì góp ý bổ sung giúp mình ở phần bình luận bên dưới nhé 😘.\n","description":"","id":38,"section":"posts","tags":["Javascript","Reactjs"],"title":"Kiến thức Javascript cơ bản cần phải biết trước khi học ReactJS","uri":"https://hungpt.info/en/posts/kien-thuc-javascript-co-ban-can-phai-biet-truoc-khi-hoc-react-native-reactjs/"},{"content":"Không lập trình viên nào code mà không có bug. Tuy nhiên có rất nhiều lỗi cơ bản chúng ta nên tránh để tạo ra ít bug hơn, code sạch và trong sáng hơn, dễ bảo trì hơn, đỡ bị ăn chửi hơn, …\n1. Xử lý quá nhiều thứ trong một function Theo nguyên tắc Single Responsibility, một function chỉ nên thực hiện một và chỉ một nhiệm vụ duy nhất. Nhiều lập trình viên hay viết một function vừa lấy dữ liệu, xử lý dữ liệu và hiển thị dữ liệu. Thay vì như vậy, hãy chia nhỏ function này ra làm 3 function: Function lấy dữ liệu, function xử lý dữ liệu và function hiển thị dữ liệu.\nViệc giữ một function chỉ tập trung thực hiện một nhiệm vụ sẽ giúp code dễ đọc và dễ bảo trì hơn. Như ví dụ trên, giả sử API để lấy dữ liệu bị thay đổi thì ta chỉ cần cập nhật lại function lấy dữ liệu, không bị ảnh hưởng đến các thao tác ở sau.\n2. Code bị comment Trong một ứng dụng lớn có nhiều lập trình viên tham gia, nhiều khi bạn sẽ thấy có các hàm, các đoạn code lớn bị comment. Bạn sẽ không hiểu đoạn code bị comment này để làm gì, ý đồ của tác giả là gì. Các lập trình viên khác có thể sẽ không dám xoá đoạn code này vì có thể tác giả của đoạn comment còn cần đến nó.\nNếu gặp trường hợp như vậy và project có sử dụng hệ thống quản lý code như git, svn, … thì hãy mạnh dạn xoá đoạn code này đi, code sẽ trở nên sạch đẹp hơn. Còn sau này nếu tác giả của đoạn code đó muốn tìm lại thì họ sẽ phải tự tìm trong các commit cũ.\n3. Đặt tên biến, tên hàm không rõ ràng Đặt tên biến là một công việc khó nhưng cũng rất quan trọng. Một tên biến rõ ràng sẽ giúp việc đọc code trở nên dễ dàng, dễ hiểu.\nHãy đặt tên biến mô tả đúng chức năng, ý nghĩa của nó, dài một chút cũng được. Tránh đặt tên biến kiểu viết tắt (trừ trường hợp phổ biến hoặc đã thống nhất từ trước) hoặc tên biến không có ý nghĩa như a, b, c, …\n4. Magic number và string Magic number và string là các giá trị duy nhất được sử dụng nhiều lần trong ứng dụng mà không có giải thích ý nghĩa rõ ràng. Những giá trị này hoàn toàn có thể thay thế bằng các biến (với điều kiện biến phải được đặt tên một cách rõ ràng).\nVí dụ với đoạn code sau:\n1 2 3  for ($i = 1; $i \u0026lt;= 52; $i++) { ... }   Trong ví dụ trên thì 52 là một magic number, và người đọc code sẽ không hiểu được 52 có ý nghĩa là gì. Thậm chí kể cả tác giả đoạn code, sau một thời gian quay lại đọc code của mình cũng không hiểu, phải dò lại toàn bộ chương trình.\nĐoạn code trên có thể viết lại như sau:\n1 2 3 4  $cardDeckSize = 52; for ($i = 1; $i \u0026lt;= $cardDeckSize; $i++) { ... }   Như vậy đọc đoạn code này sẽ hiểu ngay là đang thực hiện một vòng lặp qua từng quân bài trong bộ bài và 52 có nghĩa là số lá bài trong bộ bài. Ở các phần bên dưới cũng có thể dùng lại biến $cardDeckSize và khi cần thay đổi giá trị số lượng lá bài trong bộ bài ta cũng chỉ cần thay đổi giá trị của biến này một lần duy nhất thay vì phải sửa nhiều chỗ.\nTương tự với number, chúng ta cũng có magic string:\n1 2  ... }   và code sẽ trở nên dễ hiểu hơn.\n5. Code format lộn xộn Với những lập trình viên không có kinh nghiệm và cẩu thả thì họ sẽ viết code lộn xộn, không có format. Code không format sẽ rất khó đọc và dễ dẫn đến code sai cú pháp và rất khó debug. Ví dụ như code HTML có thẻ mở mà không có thẻ đóng dẫn đến sai cấu trúc code làm hỏng cả CSS, lỗi này cũng khó debug vì dù code sai thì cũng sẽ không báo lỗi lên trình duyệt.\nĐa số các IDE hoặc code editor hiện đại đều có hỗ trợ chức năng format code theo từng ngôn ngữ, hoặc là người dùng chủ động cài thêm các plugin, extension hỗ trợ cho việc format code. Trong một project nếu các lập trình viên dùng chung một chuẩn format code cũng sẽ giúp code đồng bộ và ít bị xung đột.\n6. Hard code Hard code là nhập dữ liệu trực tiếp vào trong source code, dữ liệu này bị fix cứng và không thay đổi, cấu hình được.\nTrong một số trường hợp chúng ta vẫn dùng hard code, tuy nhiên nếu code của bạn bị hard code quá nhiều tức là đang có vấn đề. Thay vì hard code dữ liệu trong source code, hãy tách chúng ra bằng cách lấy dữ liệu qua file cấu hình, lấy từ cơ sở dữ liệu hoặc API, hay qua biến môi trường, …\nBài viết được biên dịch lại từ medium.com.😀😀\n","description":"","id":47,"section":"posts","tags":["Javascript"],"title":"Những lỗi cơ bản trong lập trình mà developer nên tránh","uri":"https://hungpt.info/en/posts/nhung-loi-co-ban-trong-lap-trinh-ma-developer-nen-tranh/"}]